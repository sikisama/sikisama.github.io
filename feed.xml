<?xml version="1.0" encoding="UTF-8"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>sikisama的博客</title>
        <description>sikisama的博客</description>
        <link>http://sikisama.github.io</link>
        <atom:link href="http://sikisama.github.io/feed.xml" rel="self" type="application/rss+xml" />
        <pubDate>2016-08-11 10:08:18</pubDate>
        <lastBuildDate>2016-08-11 10:08:18</lastBuildDate>
        <generator>Gitblog v1.0</generator>
                <item>
            <title>nodejs入门</title>
            <description>
            &lt;!--
author: zhangxuefeng
date: 2016-08-11
title: nodejs入门
tags: nodejs
category:javascript
status: publish
summary: nodejs经典入门
--&gt;
&lt;p&gt;&lt;a href=&quot;http://www.nodebeginner.org/index-zh-cn.html&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;服务端JavaScript&quot;&gt;服务端JavaScript&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;JavaScript最早是运行在浏览器中，然而浏览器只是提供了一个上下文，它定义了使用JavaScript可以做什么，但并没有“说”太多关于JavaScript语言本身可以做什么。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;事实上，JavaScript是一门“完整”的语言：&lt;/p&gt;
&lt;p&gt;它可以使用在不同的上下文中，其能力与其他同类语言相比有过之而无不及。
Node.js事实上就是另外一种上下文，它允许在后端（脱离浏览器环境）运行JavaScript代码。&lt;/p&gt;
&lt;p&gt;要实现在后台运行JavaScript代码，代码需要先被解释然后正确的执行。Node.js的原理正是如此，它使用了Google的V8虚拟机（Google的Chrome浏览器使用的JavaScript执行环境），来解释和执行JavaScript代码。&lt;/p&gt;
&lt;p&gt;除此之外，伴随着Node.js的还有许多有用的模块，它们可以简化很多重复的劳作，比如向终端输出字符串。&lt;/p&gt;
&lt;p&gt;因此，Node.js事实上既是一个运行时环境，同时又是一个库。&lt;/p&gt;
&lt;h2 id=&quot;分析HTTP服务器&quot;&gt;分析HTTP服务器&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Node.js是事件驱动的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们创建了服务器，并且向创建它的方法传递了一个函数。无论何时我们的服务器收到一个请求，这个函数就会被调用。&lt;/p&gt;
&lt;p&gt;这个就是传说中的 回调 。我们给某个方法传递了一个函数，这个方法在有相应事件发生时调用这个函数来进行 回调 。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var http = require(&quot;http&quot;);
http.createServer(function(request,response){
  response.writeHead(200,{&quot;Content-Type&quot;:&quot;text/plain&quot;});
  response.write(&quot;Hello World&quot;);
  response.end();
}).listen(8888);&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;如何来进行请求的“路由”&quot;&gt;如何来进行请求的“路由”&lt;/h2&gt;
&lt;p&gt;我们需要的所有数据都会包含在request对象中，该对象作为onRequest()回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的Node.JS模块，它们分别是url和querystring模块。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; url.parse(string).query
                                           |
           url.parse(string).pathname      |
                       |                   |
                       |                   |
                     ------ -------------------
http://localhost:8888/start?foo=bar&amp;amp;hello=world
                                ---       -----
                                 |          |
                                 |          |
              querystring(string)[&quot;foo&quot;]    |
                                            |
                         querystring(string)[&quot;hello&quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在我们来给onRequest()函数加上一些逻辑，用来找出浏览器请求的URL路径：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var http = require(&quot;http&quot;);
var url = require(&quot;url&quot;);

function start() {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);
    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
    response.write(&quot;Hello World&quot;);
    response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log(&quot;Server has started.&quot;);
}

exports.start = start;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;使用依赖注入的方式较松散地添加路由模块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;建立一个名为router.js的文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function route(pathname) {
  console.log(&quot;About to route a request for &quot; + pathname);
}

exports.route = route;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;扩展start函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var http = require(&quot;http&quot;);
var url = require(&quot;url&quot;);

function start(route) {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);

    route(pathname);

    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
    response.write(&quot;Hello World&quot;);
    response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log(&quot;Server has started.&quot;);
}

exports.start = start;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更新index.js&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var server = require(&quot;./server&quot;);
var router = require(&quot;./router&quot;);

server.start(router.route);&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;行为驱动执行&quot;&gt;行为驱动执行&lt;/h2&gt;
&lt;p&gt;将函数作为参数传递并不仅仅出于技术上的考量。对软件设计来说，这其实是个哲学问题。想想这样的场景：在index文件中，我们可以将router对象传递进去，服务器随后可以调用这个对象的route函数。&lt;/p&gt;
&lt;p&gt;就像这样，我们传递一个东西，然后服务器利用这个东西来完成一些事。嗨那个叫路由的东西，能帮我把这个路由一下吗？&lt;/p&gt;
&lt;p&gt;但是服务器其实不需要这样的东西。它只需要把事情做完就行，其实为了把事情做完，你根本不需要东西，你需要的是动作。&lt;strong&gt;也就是说，你不需要名词，你需要动词。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;理解了这个概念里最核心、最基本的思想转换后，我自然而然地理解了函数编程。&lt;/p&gt;
&lt;p&gt;我是在读了Steve Yegge的大作&lt;a href=&quot;http://steve-yegge.blogspot.sg/2006/03/execution-in-kingdom-of-nouns.html&quot;&gt;名词王国中的死刑&lt;/a&gt;之后理解函数编程。&lt;/p&gt;
&lt;h2 id=&quot;路由给真正的请求处理程序&quot;&gt;路由给真正的请求处理程序&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在C++或C#中，当我们谈到对象，指的是类或者结构体的实例。对象根据他们实例化的模板（就是所谓的类），会拥有不同的属性和方法。但在JavaScript里对象不是这个概念。在JavaScript中，对象就是一个键/值对的集合 -- 你可以把JavaScript的对象想象成一个键为字符串类型的字典。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但如果JavaScript的对象仅仅是键/值对的集合，它又怎么会拥有方法呢？好吧，这里的值可以是字符串、数字或者……函数！&lt;/p&gt;
&lt;p&gt;我们先将这个对象引入到主文件index.js中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var server = require(&quot;./server&quot;);
var router = require(&quot;./router&quot;);
var requestHandlers = require(&quot;./requestHandlers&quot;);

var handle = {}
handle[&quot;/&quot;] = requestHandlers.start;
handle[&quot;/start&quot;] = requestHandlers.start;
handle[&quot;/upload&quot;] = requestHandlers.upload;

server.start(router.route, handle);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然handle并不仅仅是一个“东西”（一些请求处理程序的集合），我还是建议以一个动词作为其命名，这样做可以让我们在路由中使用更流畅的表达式\&lt;/p&gt;
&lt;p&gt;在完成了对象的定义后，我们把它作为额外的参数传递给服务器，为此将server.js修改如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var http = require(&quot;http&quot;);
var url = require(&quot;url&quot;);

function start(route, handle) {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);

    route(handle, pathname);

    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
    response.write(&quot;Hello World&quot;);
    response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log(&quot;Server has started.&quot;);
}

exports.start = start;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相应地在route.js文件中修改route()函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function route(handle, pathname) {
  console.log(&quot;About to route a request for &quot; + pathname);
  if (typeof handle[pathname] === 'function') {
    handle[pathname]();
  } else {
    console.log(&quot;No request handler found for &quot; + pathname);
  }
}

exports.route = route;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过以上代码，我们首先检查给定的路径对应的请求处理程序是否存在，如果存在的话直接调用相应的函数。我们可以用从关联数组中获取元素一样的方式从传递的对象中获取请求处理函数，因此就有了简洁流畅的形如handle[pathname]();的表达式，这个感觉就像在前方中提到的那样：“嗨，请帮我处理了这个路径”。&lt;/p&gt;
&lt;h2 id=&quot;阻塞与非阻塞&quot;&gt;阻塞与非阻塞&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在node中除了代码，所有一切都是并行执行的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Node.js可以在不新增额外线程的情况下，依然可以对任务进行并行处理 —— Node.js是单线程的。它通过事件轮询（event loop）来实现并行操作，对此，我们应该要充分利用这一点 —— 尽可能的避免阻塞操作，取而代之，多使用非阻塞操作。&lt;/p&gt;
&lt;p&gt;对于Node.js来说，它是这样处理的：“嘿，probablyExpensiveFunction()（这里指的就是需要花时间处理的函数），你继续处理你的事情，我（Node.js线程）先不等你了，我继续去处理你后面的代码，请你提供一个callbackFunction()，等你处理完之后我会去调用该回调函数的，谢谢！”&lt;/p&gt;
&lt;h2 id=&quot;以非阻塞操作进行请求响应&quot;&gt;以非阻塞操作进行请求响应&lt;/h2&gt;
&lt;p&gt;相对采用将内容传递给服务器的方式，我们这次采用将服务器“传递”给内容的方式。 从实践角度来说，就是将response对象（从服务器的回调函数onRequest()获取）通过请求路由传递给请求处理程序。 随后，处理程序就可以采用该对象上的函数来对请求作出响应。&lt;/p&gt;
&lt;h2 id=&quot;处理POST请求&quot;&gt;处理POST请求&lt;/h2&gt;
&lt;p&gt;考虑这样一个简单的例子：我们显示一个文本区（textarea）供用户输入内容，然后通过POST请求提交给服务器。最后，服务器接受到请求，通过处理程序将输入的内容展示到浏览器中。&lt;/p&gt;
&lt;p&gt;/start请求处理程序用于生成带文本区的表单，因此，我们将requestHandlers.js修改为如下形式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function start(response) {
  console.log(&quot;Request handler 'start' was called.&quot;);

  var body = '&amp;lt;html&amp;gt;'+
    '&amp;lt;head&amp;gt;'+
    '&amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; '+
    'charset=UTF-8&quot; /&amp;gt;'+
    '&amp;lt;/head&amp;gt;'+
    '&amp;lt;body&amp;gt;'+
    '&amp;lt;form action=&quot;/upload&quot; method=&quot;post&quot;&amp;gt;'+
    '&amp;lt;textarea name=&quot;text&quot; rows=&quot;20&quot; cols=&quot;60&quot;&amp;gt;&amp;lt;/textarea&amp;gt;'+
    '&amp;lt;input type=&quot;submit&quot; value=&quot;Submit text&quot; /&amp;gt;'+
    '&amp;lt;/form&amp;gt;'+
    '&amp;lt;/body&amp;gt;'+
    '&amp;lt;/html&amp;gt;';

    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/html&quot;});
    response.write(body);
    response.end();
}

function upload(response) {
  console.log(&quot;Request handler 'upload' was called.&quot;);
  response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
  response.write(&quot;Hello Upload&quot;);
  response.end();
}

exports.start = start;
exports.upload = upload;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了使整个过程非阻塞，Node.js会将POST数据拆分成很多小的数据块，然后通过触发特定的事件，将这些小数据块传递给回调函数。这里的特定的事件有data事件（表示新的小数据块到达了）以及end事件（表示所有的数据都已经接收完毕）。&lt;/p&gt;
&lt;p&gt;我们需要告诉Node.js当这些事件触发的时候，回调哪些函数。怎么告诉呢？ 我们通过在request对象上注册监听器（listener） 来实现。这里的request对象是每次接收到HTTP请求时候，都会把该对象传递给onRequest回调函数。&lt;/p&gt;
&lt;p&gt;如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;request.addListener(&quot;data&quot;, function(chunk) {
  // called when a new chunk of data was received
});

request.addListener(&quot;end&quot;, function() {
  // called when all chunks of data have been received
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将data和end事件的回调函数直接放在服务器中，在data事件回调中收集所有的POST数据，当接收到所有数据，触发end事件后，其回调函数调用请求路由，并将数据传递给它，然后，请求路由再将该数据传递给请求处理程序。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var http = require(&quot;http&quot;);
var url = require(&quot;url&quot;);

function start(route, handle) {
  function onRequest(request, response) {
    var postData = &quot;&quot;;
    var pathname = url.parse(request.url).pathname;
    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);

    request.setEncoding(&quot;utf8&quot;);

    request.addListener(&quot;data&quot;, function(postDataChunk) {
      postData += postDataChunk;
      console.log(&quot;Received POST data chunk '&quot;+
      postDataChunk + &quot;'.&quot;);
    });

    request.addListener(&quot;end&quot;, function() {
      route(handle, pathname, response, postData);
    });

  }

  http.createServer(onRequest).listen(8888);
  console.log(&quot;Server has started.&quot;);
}

exports.start = start;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们接下来在/upload页面，展示用户输入的内容。要实现该功能，我们需要将postData传递给请求处理程序，修改router.js为如下形式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function route(handle, pathname, response, postData) {
  console.log(&quot;About to route a request for &quot; + pathname);
  if (typeof handle[pathname] === 'function') {
    handle[pathname](response, postData);
  } else {
    console.log(&quot;No request handler found for &quot; + pathname);
    response.writeHead(404, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
    response.write(&quot;404 Not found&quot;);
    response.end();
  }
}

exports.route = route;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，在requestHandlers.js中，我们将数据包含在对upload请求的响应中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function start(response, postData) {
  console.log(&quot;Request handler start was called.&quot;);

  var body = '&amp;lt;html&amp;gt;'+
    '&amp;lt;head&amp;gt;'+
    '&amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; '+
    'charset=UTF-8&quot; /&amp;gt;'+
    '&amp;lt;/head&amp;gt;'+
    '&amp;lt;body&amp;gt;'+
    '&amp;lt;form action=&quot;/upload&quot; method=&quot;post&quot;&amp;gt;'+
    '&amp;lt;textarea name=&quot;text&quot; rows=&quot;20&quot; cols=&quot;60&quot;&amp;gt;&amp;lt;/textarea&amp;gt;'+
    '&amp;lt;input type=&quot;submit&quot; value=&quot;Submit text&quot; /&amp;gt;'+
    '&amp;lt;/form&amp;gt;'+
    '&amp;lt;/body&amp;gt;'+
    '&amp;lt;/html&amp;gt;';

    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/html&quot;});
    response.write(body);
    response.end();
}

function upload(response, postData) {
  console.log(&quot;Request handler upload was called.&quot;);
  response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
  //querystring.parse(postData).text;
  response.write(&quot;You've sent: &quot; + postData);
  response.end();
}

exports.start = start;
exports.upload = upload;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;处理文件上传&quot;&gt;处理文件上传&lt;/h2&gt;
&lt;p&gt;这里我们要用到的外部模块是Felix Geisendörfer开发的node-formidable模块。它对解析上传的文件数据做了很好的抽象。&lt;/p&gt;
&lt;p&gt;Node.js有它自己的包管理器，叫NPM。它可以让安装Node.js的外部模块变得非常方便。通过如下一条命令就可以完成该模块的安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install formidable&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们来添加/showURL的请求处理程序，该处理程序直接硬编码将文件/tmp/test.png内容展示到浏览器中。将requestHandlers.js修改为如下形式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var querystring = require(&quot;querystring&quot;),
    fs = require(&quot;fs&quot;);

function start(response, postData) {
  console.log(&quot;Request handler 'start' was called.&quot;);

  var body = '&amp;lt;html&amp;gt;'+
    '&amp;lt;head&amp;gt;'+
    '&amp;lt;meta http-equiv=&quot;Content-Type&quot; '+
    'content=&quot;text/html; charset=UTF-8&quot; /&amp;gt;'+
    '&amp;lt;/head&amp;gt;'+
    '&amp;lt;body&amp;gt;'+
    '&amp;lt;form action=&quot;/upload&quot; method=&quot;post&quot;&amp;gt;'+
    '&amp;lt;textarea name=&quot;text&quot; rows=&quot;20&quot; cols=&quot;60&quot;&amp;gt;&amp;lt;/textarea&amp;gt;'+
    '&amp;lt;input type=&quot;submit&quot; value=&quot;Submit text&quot; /&amp;gt;'+
    '&amp;lt;/form&amp;gt;'+
    '&amp;lt;/body&amp;gt;'+
    '&amp;lt;/html&amp;gt;';

    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/html&quot;});
    response.write(body);
    response.end();
}

function upload(response, postData) {
  console.log(&quot;Request handler 'upload' was called.&quot;);
  response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
  response.write(&quot;You've sent the text: &quot;+
  querystring.parse(postData).text);
  response.end();
}

function show(response, postData) {
  console.log(&quot;Request handler 'show' was called.&quot;);
  fs.readFile(&quot;/tmp/test.png&quot;, &quot;binary&quot;, function(error, file) {
    if(error) {
      response.writeHead(500, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
      response.write(error + &quot;\n&quot;);
      response.end();
    } else {
      response.writeHead(200, {&quot;Content-Type&quot;: &quot;image/png&quot;});
      response.write(file, &quot;binary&quot;);
      response.end();
    }
  });
}

exports.start = start;
exports.upload = upload;
exports.show = show;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;好，最后我们要的就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在/start表单中添加一个文件上传元素&lt;/li&gt;
&lt;li&gt;将node-formidable整合到我们的upload请求处理程序中，用于将上传的图片保存到/tmp/test.png&lt;/li&gt;
&lt;li&gt;将上传的图片内嵌到/uploadURL输出的HTML中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一项很简单。只需要在HTML表单中，添加一个multipart/form-data的编码类型，移除此前的文本区，添加一个文件上传组件，并将提交按钮的文案改为“Upload file”即可。 如下requestHandler.js所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var querystring = require(&quot;querystring&quot;),
    fs = require(&quot;fs&quot;);

function start(response, postData) {
  console.log(&quot;Request handler 'start' was called.&quot;);

  var body = '&amp;lt;html&amp;gt;'+
    '&amp;lt;head&amp;gt;'+
    '&amp;lt;meta http-equiv=&quot;Content-Type&quot; '+
    'content=&quot;text/html; charset=UTF-8&quot; /&amp;gt;'+
    '&amp;lt;/head&amp;gt;'+
    '&amp;lt;body&amp;gt;'+
    '&amp;lt;form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot; '+
    'method=&quot;post&quot;&amp;gt;'+
    '&amp;lt;input type=&quot;file&quot; name=&quot;upload&quot;&amp;gt;'+
    '&amp;lt;input type=&quot;submit&quot; value=&quot;Upload file&quot; /&amp;gt;'+
    '&amp;lt;/form&amp;gt;'+
    '&amp;lt;/body&amp;gt;'+
    '&amp;lt;/html&amp;gt;';

    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/html&quot;});
    response.write(body);
    response.end();
}

function upload(response, postData) {
  console.log(&quot;Request handler 'upload' was called.&quot;);
  response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
  response.write(&quot;You've sent the text: &quot;+
  querystring.parse(postData).text);
  response.end();
}

function show(response, postData) {
  console.log(&quot;Request handler 'show' was called.&quot;);
  fs.readFile(&quot;/tmp/test.png&quot;, &quot;binary&quot;, function(error, file) {
    if(error) {
      response.writeHead(500, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
      response.write(error + &quot;\n&quot;);
      response.end();
    } else {
      response.writeHead(200, {&quot;Content-Type&quot;: &quot;image/png&quot;});
      response.write(file, &quot;binary&quot;);
      response.end();
    }
  });
}

exports.start = start;
exports.upload = upload;
exports.show = show;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下一步相对比较复杂。这里有这样一个问题： 我们需要在upload处理程序中对上传的文件进行处理，这样的话，我们就需要将request对象传递给node-formidable的form.parse函数。&lt;/p&gt;
&lt;p&gt;但是，我们有的只是response对象和postData数组。看样子，我们只能不得不将request对象从服务器开始一路通过请求路由，再传递给请求处理程序。 或许还有更好的方案，但是，不管怎么说，目前这样做可以满足我们的需求。&lt;/p&gt;
&lt;p&gt;我们从server.js开始 —— 移除对postData的处理以及request.setEncoding （这部分node-formidable自身会处理），转而采用将request对象传递给请求路由的方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var http = require(&quot;http&quot;);
var url = require(&quot;url&quot;);

function start(route, handle) {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);
    route(handle, pathname, response, request);
  }

  http.createServer(onRequest).listen(8888);
  console.log(&quot;Server has started.&quot;);
}

exports.start = start;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来是 router.js —— 我们不再需要传递postData了，这次要传递request对象：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function route(handle, pathname, response, request) {
  console.log(&quot;About to route a request for &quot; + pathname);
  if (typeof handle[pathname] === 'function') {
    handle[pathname](response, request);
  } else {
    console.log(&quot;No request handler found for &quot; + pathname);
    response.writeHead(404, {&quot;Content-Type&quot;: &quot;text/html&quot;});
    response.write(&quot;404 Not found&quot;);
    response.end();
  }
}

exports.route = route;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来，我们把处理文件上传以及重命名的操作放到一起，如下requestHandlers.js所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var querystring = require(&quot;querystring&quot;),
    fs = require(&quot;fs&quot;),
    formidable = require(&quot;formidable&quot;);

function start(response) {
  console.log(&quot;Request handler 'start' was called.&quot;);

  var body = '&amp;lt;html&amp;gt;'+
    '&amp;lt;head&amp;gt;'+
    '&amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; '+
    'charset=UTF-8&quot; /&amp;gt;'+
    '&amp;lt;/head&amp;gt;'+
    '&amp;lt;body&amp;gt;'+
    '&amp;lt;form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot; '+
    'method=&quot;post&quot;&amp;gt;'+
    '&amp;lt;input type=&quot;file&quot; name=&quot;upload&quot; multiple=&quot;multiple&quot;&amp;gt;'+
    '&amp;lt;input type=&quot;submit&quot; value=&quot;Upload file&quot; /&amp;gt;'+
    '&amp;lt;/form&amp;gt;'+
    '&amp;lt;/body&amp;gt;'+
    '&amp;lt;/html&amp;gt;';

    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/html&quot;});
    response.write(body);
    response.end();
}

function upload(response, request) {
  console.log(&quot;Request handler 'upload' was called.&quot;);

  var form = new formidable.IncomingForm();
  console.log(&quot;about to parse&quot;);
  form.parse(request, function(error, fields, files) {
    console.log(&quot;parsing done&quot;);
    fs.renameSync(files.upload.path, &quot;/tmp/test.png&quot;);
    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/html&quot;});
    response.write(&quot;received image:&amp;lt;br/&amp;gt;&quot;);
    response.write(&quot;&amp;lt;img src='/show' /&amp;gt;&quot;);
    response.end();
  });
}

function show(response) {
  console.log(&quot;Request handler 'show' was called.&quot;);
  fs.readFile(&quot;/tmp/test.png&quot;, &quot;binary&quot;, function(error, file) {
    if(error) {
      response.writeHead(500, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
      response.write(error + &quot;\n&quot;);
      response.end();
    } else {
      response.writeHead(200, {&quot;Content-Type&quot;: &quot;image/png&quot;});
      response.write(file, &quot;binary&quot;);
      response.end();
    }
  });
}

exports.start = start;
exports.upload = upload;
exports.show = show;&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-08-11 10:36:31</pubDate>
            <link>http://sikisama.github.io/blog/nodejs_guide.html</link>
            <guid isPermaLink="true">http://sikisama.github.io/blog/nodejs_guide.html</guid>
                                               <category>javascript</category>
                                    </item>
                <item>
            <title>mdx重要概念</title>
            <description>
            &lt;!--
author: zhangxuefeng
date: 2016-07-07
title: mdx重要概念
tags: mdx
category: database
status: publish
summary: mdx重要概念
--&gt;
&lt;blockquote&gt;
&lt;p&gt;Mdx为多维数据库提供了表达式语查询语法，用于cube数据，并提供了许多强大的分析函数，用于支持常用的OLAP分析。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;语法&quot;&gt;语法&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;维度、级别、成员等，一般用唯一名称UniqueName来标示，可以用[]包围name,如果name有空格或者数字开头，必须使用[],否则可以忽略。UniqueName是根据层次结构表示的一种方法。即递归显示出祖先的名称。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;维度（Dimension):维度直接用[]包围。比如Product的唯一名称为[Product]或Product。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[属性]是维度的基本构造块。 维度包含一组在属性关系基础上组织而成的属性。具有对外关系的任何属性必须具有与其相关属性关联的唯一键。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;级别（Level）:级别的UniqueName为[维度名称].[级别名称]，如[year].[2001]，同样，如果没有空格，[]可以省略，如year.[2001]。&lt;/li&gt;
&lt;li&gt;成员（Member）:成员的UniqueName格式为[维度].(Parent  Member  UniqueName).[Member Name],如：时间维上的2003年2月份的UniqueName为[2003].[1].[2]，中间的1为1季度，因为该维度的结构为年、季、月。&lt;/li&gt;
&lt;li&gt;度量（Measure）:度量实际上是属于维度维的成员，也就是说度量（Measure）是任何Cube的一个维度。如：度量Unit Sales的UnqiueName为[Measures].[Unit Sales]&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;元组、集合&quot;&gt;元组、集合&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;元组用于定义来自多维数据切片；他是由一个或多个维度的单个成员的有序集合组成。元组内不包含来自同一个维度的多个成员（可以理解为坐标），元组用（）包围。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;p&gt;（时间.[下半年]）&lt;/p&gt;
&lt;p&gt;（时间.[下半年],[产品].[手机].[Nokia]）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;集合（Set）是零个、一个或多个元组的有序集合。集合最常用于在Mdx查询中定义轴维度和切片器维度，并且同样可能只具有单个元组或可能在某些情况下为空。在Mdx语法中，元组用花括号{}来构造集合&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;举例，下面是具有两个元组的集合：&lt;/p&gt;
&lt;p&gt;{（时间.[上半年],路线.非陆地.航空），（时间.[下半年]，路线.非陆地.海路）}&lt;/p&gt;
&lt;p&gt;一个集合可包含同一个元组不止一次的出现。这样也是可以的：&lt;/p&gt;
&lt;p&gt;{时间.[下半年],时间.[下半年]}&lt;/p&gt;
&lt;p&gt;集合值以元组表示的一组成员组合，或指集合中的元组所代表的单元中的值，视集合使用的上下文而定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：单个元组的集合不等于元组。如{时间.[下半年]}不等于  时间.[下半年]。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;Mdx基本语法结构&quot;&gt;Mdx基本语法结构&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;    SELECT  [axis specification] ON COLUMNS,

                [axis specification] ON ROWS

   FROM

                [cube name]

   WHERE

              [silcer specification]&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;[axis specification]可以看成是轴的成员选择。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;[silcer specification]表示切片上的成员，可以看成过滤信息，[silcer specification]可选，如果没有指定，取系统默认的维度成员作为切片&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;轴维度和切片器维度&quot;&gt;轴维度和切片器维度&lt;/h2&gt;
&lt;p&gt;当设计多维表达式（Mdx）查询时，应用程序一般查看多维数据集并将维度集合划分为两个子集：&lt;/p&gt;
&lt;p&gt;1.查询轴 - 从此层次结构集中检索多个成员的数据。&lt;/p&gt;
&lt;p&gt;2.切片器轴 - 从此层次结构集中检索单个成员的数据。&lt;/p&gt;            </description>
            <pubDate>2016-07-05 14:51:27</pubDate>
            <link>http://sikisama.github.io/blog/mdx.html</link>
            <guid isPermaLink="true">http://sikisama.github.io/blog/mdx.html</guid>
                                               <category>database</category>
                                    </item>
                <item>
            <title>正则表达式与preg函数</title>
            <description>
            &lt;!--
author: zhangxuefeng
date: 2016-06-27
title: 正则表达式与preg函数
tags: 正则表达式
category: tool
status: publish
summary: 正则规范
--&gt;
&lt;p&gt;&lt;a href=&quot;http://www.noupe.com/development/php-regular-expressions.html&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;operator&lt;/th&gt;
&lt;th&gt;DESCRIPTION&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;The circumflex symbol marks the beginning of a pattern, although in some cases it can be omitted&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$&lt;/td&gt;
&lt;td&gt;Same as with the circumflex symbol, the dollar sign marks the end of a search pattern&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;The period matches any single character&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;It will match the preceding pattern zero or one times&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;It will match the preceding pattern one or more times&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;It will match the preceding pattern zero or more times&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;|&lt;/td&gt;
&lt;td&gt;Boolean OR&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;–&lt;/td&gt;
&lt;td&gt;Matches a range of elements&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;()&lt;/td&gt;
&lt;td&gt;Groups a different pattern elements together&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[]&lt;/td&gt;
&lt;td&gt;Matches any single character between the square brackets&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;{min, max}&lt;/td&gt;
&lt;td&gt;It is used to match exact character counts&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\d&lt;/td&gt;
&lt;td&gt;Matches any single digit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\D&lt;/td&gt;
&lt;td&gt;Matches any single non digit caharcter&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\w&lt;/td&gt;
&lt;td&gt;Matches any alpha numeric character including underscore (_)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\W&lt;/td&gt;
&lt;td&gt;Matches any non alpha numeric character excluding the underscore character&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\s&lt;/td&gt;
&lt;td&gt;Matches whitespace character&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;EXAMPLE&lt;/th&gt;
&lt;th&gt;DESCRIPTION&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;‘/hello/’&lt;/td&gt;
&lt;td&gt;It will match the word hello&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘/^hello/’&lt;/td&gt;
&lt;td&gt;It will match hello at the start of a string. Possible matches are hello or helloworld, but not worldhello&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘/hello$/’&lt;/td&gt;
&lt;td&gt;It will match hello at the end of a string.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘/he.o/’&lt;/td&gt;
&lt;td&gt;It will match any character between he and o. Possible matches are helo or heyo, but not hello&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘/he?llo/’&lt;/td&gt;
&lt;td&gt;It will match either llo or hello&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘/hello+/’&lt;/td&gt;
&lt;td&gt;It will match hello on or more time. E.g. hello or hellohello&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘/he*llo/’&lt;/td&gt;
&lt;td&gt;Matches llo, hello or hehello, but not hellooo&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘/hello&lt;/td&gt;
&lt;td&gt;world/’&lt;/td&gt;
&lt;td&gt;It will either match the word hello or world&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘/(A-Z)/’&lt;/td&gt;
&lt;td&gt;Using it with the hyphen character, this pattern will match every uppercase character from A to Z. E.g. A, B, C…&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘/[abc]/’&lt;/td&gt;
&lt;td&gt;It will match any single character a, b or c&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘/abc{1}/’&lt;/td&gt;
&lt;td&gt;Matches precisely one c character after the characters ab. E.g. matches abc, but not abcc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘/abc{1,}/’&lt;/td&gt;
&lt;td&gt;Matches one or more c character after the characters ab. E.g. matches abc or abcc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘/abc{2,4}/’&lt;/td&gt;
&lt;td&gt;Matches between two and four c character after the characters ab. E.g. matches abcc, abccc or abcccc, but not abc&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;常用函数&quot;&gt;常用函数&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://php.net/manual/zh/function.preg-match.php&quot;&gt;preg_match&lt;/a&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://php.net/manual/zh/function.preg-replace.php&quot;&gt;preg_repalce&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;game&quot;&gt;game&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://regex.alf.nu/&quot;&gt;title&lt;/a&gt;
&lt;a href=&quot;http://felixc.at/regex.alf.nu&quot;&gt;answer&lt;/a&gt;&lt;/p&gt;            </description>
            <pubDate>2016-08-05 11:00:48</pubDate>
            <link>http://sikisama.github.io/blog/reg_express.html</link>
            <guid isPermaLink="true">http://sikisama.github.io/blog/reg_express.html</guid>
                                               <category>tool</category>
                                    </item>
                <item>
            <title>Git使用指南</title>
            <description>
            &lt;!--
author: zhangxuefeng
date: 2016-06-07
title: Git使用指南
tags: Git
category:tool
status: publish
summary: 总结一些git常用的命令
--&gt;
&lt;h2 id=&quot;一.创建与添加&quot;&gt;一.创建与添加&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;1.git init //将一个目录初始化为git仓库&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建立一个空的仓库，目录下会多一个.git的隐藏文件夹，用来跟踪管理版本库。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2.git add //添加文件到缓存&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将文件添加至缓存，多个文件用空格分隔&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;git add .&lt;/strong&gt; 或 &lt;strong&gt;git add  *&lt;/strong&gt; 可以递归的添加当前目录的所有文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3.git commit -m 'comments' //记录缓存内容的快照&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将（已缓存的/已add的）文件提交到仓库，生成快照&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;4.git commit -a &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自动将在提交前已记录、修改的文件放入缓存区(跳过add)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;5.git clone [url] [new_name] //复制一个Git仓库
eg. git clone https://github.com/sikisama/sikisama.github.io
or
git clone git://github.com/sikisama/sikisama.github.io&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;二、查看与修改&quot;&gt;二、查看与修改&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;1.git status / git status -s //查看工作目录与缓存状态&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看代码在缓存与当前工作目录的状态。带-s参数显示简短的结果，第一栏是缓存（add之后），第二栏是工作目录（add之前）。&lt;/p&gt;
&lt;p&gt;用于查看上一次提交之后(commit)有什么被修改或临时提交的（add）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2.git diff  //尚未缓存的改动&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示上次提交快照（commit）之后尚未缓存(add)的所有修改。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;执行完git status 再跑一下 git diff 是好习惯&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;3.git diff --cached   //已缓存的改动&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示接下来将要写入快照的内容（after add before commit ）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;4.git diff HEAD&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看已缓存与未缓存的改动，也就是工作目录与上一次提交(commit)的更新区别，无视缓存。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;5.git diff --stat //显示摘要&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示摘要而非整个diff&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;6.git reset HEAD -- file //已缓存与未缓存的改动&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;取消&lt;/strong&gt;已经缓存（add）的内容，将缓存区恢复到做出修改之前的样子。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//回退到之前的若干个版本(commit)
git reset --hard HEAD^/HEAD~[n]
git reset --hard [commit_id]

7.git rm &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将文件从缓存区&lt;strong&gt;移除&lt;/strong&gt;，如果要在目录中保留，使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git rm --cached

8.git mv  //git rm --cached orig;mv orig new;git add new&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;三、远程仓库&quot;&gt;三、远程仓库&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;使用 git fetch 更新你的项目，使用 git push 分享你的改动。 你可以用 git remote 管理你的远程仓库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;1.git remote /git remote -v //罗列添加和删除远端仓库的别名&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当你需要与远端仓库同步的时候，不需要使用它详细的链接。Git 储存了你感兴趣的远端仓库的链接的别名或者昵称。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2.git remote add [alias] [url]//为项目添加一个远程仓库

3.git remote rm [alias] //删除现存的某个别名

4.git fetch //从远端下载新分支与数据&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;想要同步远端信息，首先 git fetch [alias] 告诉git去获取数据，然后执行 git merge [alias]/[branch]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;5.git pull //从远端仓库提取数据并尝试合并到当前分支,在git fetch 后 git merge 

6.git push [alias] [branch]//推送你的新分支到某个远端仓库&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;会将你的[branch]分支推送成[alias]远端上的[branch]分支。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;git push [alias] [branch] 将你的本地改动推送到远端仓库。 如果可以的话，它会依据你的 [branch] 的样子，推送到远端的 [branch] 去。 如果在你上次提取、合并之后，另有人推送了，Git 服务器会拒绝你的推送，知道你是最新的为止。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;修正这个问题:执行 git fetch github; git merge github/master，然后再推送。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;四、分支与合并&quot;&gt;四、分支与合并&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;执行 git branch [branchname] 来创建分支，用 git checkout [branchname] 命令切换到该分支。当切换分支的时候，git会用该分支最后提交的快照来替换工作目录的内容。使用 git merge 来合并分支。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;1.git branch //列出、创建与管理工作上下文

2.git checkout [branchname] //切换到新的分支上下文

3.git branch [branchname] //切换到新的分支上下文&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;git将还原你的工作目录到你创建分支时的样子——可以把它看做一个记录你当前进度的书签。    &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;4.git checkout -b [branchname] //创建新分支并立即切换到它

5.git branch -d [branchname] //删除分支

6.git merge [branchname] //将分支合并到当前分支&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;合并冲突&lt;/strong&gt;
不同分支修改了相同区块的代码，就会出现冲突。使用git diff 可以显示冲突的双方和冲突解决的方法。使用git add告诉git文件中的冲突已经解决。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;7.git log //显示一个分支中提交的更改记录

8.git log --online //查看紧凑简介的版本，--graph 选项查看历史中出现的分支和合并

9.git log --online master ^dev //在不想看到的分支前放一个 ^

10.git tag //给历史记录中某个重要的一点打上标签

git tag -a [v] [sha]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考资料&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://codeigniter.org.cn/&quot;&gt;git参考手册&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot;&gt;git教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;            </description>
            <pubDate>2016-08-05 11:12:07</pubDate>
            <link>http://sikisama.github.io/blog/git_instruction_manual.html</link>
            <guid isPermaLink="true">http://sikisama.github.io/blog/git_instruction_manual.html</guid>
                                               <category>tool</category>
                                    </item>
            </channel>
</rss>