<?xml version="1.0" encoding="UTF-8"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>sikisama的博客</title>
        <description>sikisama的博客</description>
        <link>http://sikisama.github.io</link>
        <atom:link href="http://sikisama.github.io/feed.xml" rel="self" type="application/rss+xml" />
        <pubDate>2016-09-06 14:09:29</pubDate>
        <lastBuildDate>2016-09-06 14:09:29</lastBuildDate>
        <generator>Gitblog v1.0</generator>
                <item>
            <title>javascript语言精粹-数组</title>
            <description>
            &lt;!--
author: zhangxuefeng
date: 2016-09-06
title: javascript语言精粹-数组
tags: javascript
category:javascript
status: publish
summary: javascript语言精粹读书笔记
--&gt;
&lt;h3 id=&quot;数组&quot;&gt;数组&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;javascript 提供一种拥有一些类数组(array-like)特性的对象。它把数组下标转变成字符串，用其作为索引。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;var numbers = ['zero','one','two','three','four','five','six'];
var numbers_obj = {0:'zero',1:'one',2:'two',3:'three',4:'four',5:'five',6:'six'};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;两者产生的结果相似。numbsers继承自Array.prototype，而numbers_obj继承自Object.prototype，所以numbers继承了大量有用的方法，同时还有一个length属性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;长度  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个数组都有一个length属性，它的值是这个数组的最大整数属性名加上1。它不一定等于这个数组里的属性的个数。&lt;/p&gt;
&lt;p&gt;设置更大的length不会给数组分配更多的空间，而把length设小将导致所有下标大于等于新length的属性被删除。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 新增一个元素到数组的尾部
numbsers[numbsers.length] = 'seven';
or
numbsers.push('eight');&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;删除&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于 javascript的数组其实就是对象，所以delete运算符可以用来从数组中移除元素，但是这样会在数组中留下一个空洞。&lt;/p&gt;
&lt;p&gt;slice方法可以删除一些元素并将他们替换为其他元素&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组与对象&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;当属性名是小而连续的整数时用数组，否则使用对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;
var is_array = function(value){
    return value &amp;amp;&amp;amp; typeof value === 'object' &amp;amp;&amp;amp; value.constructor = Array;
}

var is_array = function(value){
    return Object.prototype.toString.apply(value) === '[object Array]';
}&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;javascript提供一套数组可用的方法。这些方法是存储在Array.prototype中的函数，Array.prototype同样也是可以扩充的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Array.method('reduce',function(f,value){
    var i;
    for(i = 0;i&amp;lt;this.length;i += 1){
        value = f(this[i],value);
    }
    return value;
});

var data = [1,2,3,4];

var add = function(a,b){
    return a+b;
}

var mult = function(a,b){
    return a*b;
}

var sum = data.reduce(add,0);

var product = data.reduce(mult,1);

//因为数组其实就是对象，可以给一个单数的数组添加方法

data.total = function(){
    return this.reduce(add,0);
}

var total = data.total();&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为字符串'total'不是整数，所以给数组增加一个total属性【并不会】改变它的length属性。当属性名是整数时，数组才是最有用的，但它依旧是对象，并且可以接受任何字符串作为属性名。&lt;/p&gt;
&lt;p&gt;Object.create方法在数组中是没有意义的，因为它产生一个对象，而不是一个数组。产生的对象将继承这个数组的值和方法，但是没有那个特殊的length属性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;预设值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;javascript数组通常不会设置预设值。如果用[]定义一个新的数组，它将会是空的。如果访问一个不存在的元素，将会是undefined。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Array.dim = function(dimension,initial){
    var a = [],i;
    for(i = 0;i &amp;lt; dimension; i+=1){
        a[i] = initial;
    }
    return a;
};

var myArray = Array.dim(10,0);&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-09-06 14:40:20</pubDate>
            <link>http://sikisama.github.io/blog/js_thegoodpart_array.html</link>
            <guid isPermaLink="true">http://sikisama.github.io/blog/js_thegoodpart_array.html</guid>
                                               <category>javascript</category>
                                    </item>
                <item>
            <title>javascript语言精粹-对象与函数</title>
            <description>
            &lt;!--
author: zhangxuefeng
date: 2016-09-02
title: javascript语言精粹-对象与函数
tags: javascript
category:javascript
status: publish
summary: javascript语言精粹读书笔记
--&gt;
&lt;h3 id=&quot;对象&quot;&gt;对象&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;javascript中，对象是可变的键控集合（keyed collection）。对象是属性的容器，其中每个属性都拥有名字和值。属性的名字可以是包含字符串在内的任意字符。属性值可以是除undefined值外的任何值。&lt;/li&gt;
&lt;li&gt;javascript 包含一个原型链的特性，允许对象继承另外一个对象的属性。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个对象的字面量就是包围在一对花括号中的零或多个【键值对】。&lt;/p&gt;
&lt;p&gt;'||' 会取第一个为true的,'&amp;amp;&amp;amp;'会尝试取到最后一个为true的（遇到false停止）
可以用 '||' 来填充默认值 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var person = {'name':'zxf','age':24};
var status = person.status || &quot;unknown&quot;;
//尝试从undefined的成员属性中取值会导致 TypeError异常，可以通过&amp;amp;&amp;amp;运算符来避免错误
var gril_name = person.girl &amp;amp;&amp;amp; person.girl.name;&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;对象通过引用传递，&lt;strong&gt;永远不会被复制&lt;/strong&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;var a = b = c = {};&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;反射机制&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;typeof person.name 
//检测对象是独有该属性，不检查原型链
person.hasOwnProperty('name');&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;delete 可以删除对象属性，它不会触及原型链中的对象（可能使原型链中的同名属性暴露出来）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;函数&quot;&gt;函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;函数&lt;/strong&gt;包含一组语句，他们是javascript的基础模块单元，用于代码复用，信息隐藏和组合调用。函数用于指定对象的行为，所谓编程，就是将一组需求分解成一组函数与数据结构的技能。&lt;/li&gt;
&lt;li&gt;javascript中函数就是对象。对象是【名/值】对的集合并拥有一个连接到原型对象的隐藏连接。对象的字面常量连接到Object.protoype（也是一个object）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为函数时对象，所以他们可以像任何其他值一样被使用。
函数可以在保存变量、对象和数组中。函数可以被当做参数传递给其他函数，函数也可以再返回函数。而且，因为函数时对象，所以函数可以拥有方法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;函数的与众不同在于他们可以被调用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;调用一个函数会暂停当前函数的执行，传递控制权和参数给新函数。除了申明是定义的形参，每个函数还接受两个附加的参数：this和arguments。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;调用运算符&lt;/strong&gt; 是跟在任何一个函数表达式之后的一对圆括号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var that = this;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;基本类型扩充 &lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;Function.prototype.method = function(name,func){
    if(!this.prototype[name]){
        this.prototype[name] = func;
    } 
    return this
}

Number.method('integer',function(){
    return Math[this &amp;lt; 0 ? 'ceil':'floor'](this); 
});

(-10/3).integer();&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;【作用域】 在编程语言中，作用域控制着变量与参数的可见性与生命周期，它减少了命名冲突，提供了自动的内存管理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;javascript 并不支持块级作用域，只有函数作用域。意味着定义在函数内的参数和变量在函数外是不可见的；而在一个函数内部任何位置定义的变量，在该函数内部任何位置都可见。&lt;/p&gt;
&lt;p&gt;最好的做法是在函数体的顶部声明函数中可能用到的所有变量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;【闭包】 避免在循环中创建函数，可以在循环之外创建一个辅助函数，让这个辅助函数绑定参数，避免引起混淆。&lt;/li&gt;
&lt;li&gt;【模块】 我们可以使用函数和闭包来构造模块。模块是一个提供接口却隐藏状态与实现的函数或对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;柯里化&quot;&gt;柯里化&lt;/h3&gt;
&lt;p&gt;允许我们把参数与传递给它的参数结合，产生一个新的函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function add(){var sum = 0; for(i=0;i&amp;lt;arguments.length;i++){sum += arguments[i];} return sum;}

Function.method('curry',function(){
    var slice = Array.prototype.slice,
        args = slice.apply(arguments),
        that = this;
        console.log(args);//[1]
        console.log(arguments);//[1]
        console.log(this);//function add(){}
        console.log(that);//function add(){}
        return function(){
        console.log('666');
        console.log(arguments);//[6]
        console.log(args);//[1]
        console.log(this);//window
        console.log(that);//function add(){}
            return that.apply(null,args.concat(slice.apply(arguments)));
        }
});

//调用
var add1 = add.curry(1);
document.writeln(add1(6));
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;记忆&quot;&gt;记忆&lt;/h3&gt;
&lt;p&gt;函数可以将先前操作的结果记录在某个对象里，从而避免重复的运算。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;定义一个函数，然后返回它。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;var memoizer = function(memo,formula){
    var recur = function(n){
        var result = memo[n];
        if(typeof result !== 'number'){
            result = formula(recur,n);
            memo[n] = result;
        }
        return result;
    }
    return recur;
}

var fibonacci = memoizer([0,1],function(recur,n){
    return recur(n-1) + recur(n-2);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;继承&quot;&gt;继承&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;继承提供了两个有用的服务。首先是代码重用的一种形式。另外一个好处是引入了一套类型系统的规范，程序员无需编写显示类型转换的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;javascript是一门弱类型语言，从不需要类型转换。对象的集成关系变得无关紧要。对于一个对象来说重要的是&lt;strong&gt;它能做什么&lt;/strong&gt;，而不是它从哪里来。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Function.method('inherits',function(Parent){
    this.prototype = new Parent();
    return this;
});

//定义构造器
var Mammal = function(name){
    this.name = name;
}
Mammal.prototype.get_name = function(){
    return this.name;
}
Mammal.prototype.says = function(){
    return this.saying || '';
}

var Cat = function(name){
    this.name = name;
    this.saying = 'meow';
}

Cat.prototype = new Mammal('From the Mammal');
Cat.prototype.purr = function(n){
    var i,s = '';
    for(i=0;i&amp;lt;n;i++){
        if(s){
            s += '-';
        }
        s += 'r';
    }
    return s;
};
Cat.prototype.get_name = function(){
    return this.says() + ' '+ this.name +' ' + this.says();
};

var myCat = new Cat('Tom');
myCat.says();
myCat.purr(5);
myCat.get_name();

//会从原型链上找方法&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;原型&quot;&gt;原型&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;基于原型的继承：一个对象可以继承一个旧对象的属性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;var myMammal = {
    name:'the Mammal',
    get_name : function(){
        return this.name;
    },
    says:function(){
        return this.saying || '';
    }
}

//差异化继承

var myCat = Object.create(myMammal);
myCat.name = 'Tom';
myCat.saying = 'meow';
myCat.purr = function(n){
    var i,s = '';
    for(i=0;i&amp;lt;n;i++){
        if(s){
            s += '-';
        }
        s += 'r';
    }
    return s;
};
myCat.get_name = function(){
    return this.says() + ' '+ this.name +' ' + this.says();
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;函数化&quot;&gt;函数化&lt;/h3&gt;
&lt;p&gt;继承模式的一个弱点就是没法保护隐私，对象的属性都是可以见的。&lt;/p&gt;
&lt;p&gt;应用模块模式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//spec对象包含构造器需要构造一个新实例的所有信息
//my对象是一个为继承链中的构造器提供秘密共享的容器。my对象可以选择新的使用，如果没有传入一个my对象，那么会创建一个my对象。
var constructor = function(spec,my){
    var that,其他私有实例变量
    my = my || {};
    //把共享变量和函数添加到my中
    that = 一个新对象
    添加that的特权方法
    return that;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var mammal = function(spec){
    var that = {};

    that.get_name = function(){
        return spec.name;  
    };

    that.says = function(){
        return spec.saying || '';
    };
    return that;
}

var myMammal = mammal({name:'mammal'});

var cat = function (spec){
    spec.saying = spec.saying || 'meow';
    var that= mammal(spec);
    that.purr = function(n){
        var i,s = '';
        for(i=0;i&amp;lt;n;i++){
            if(s){
                s += '-';
            }
            s += 'r';
        }
        return s;
    };
    that.get_name = function(){
        return that.says() + ' '+ spec.name +' ' + that.says();
    };
    return that;
};

var myCat = cat({name:'Tom'});
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;//先给function添加method方法
Function.prototype.method = function(name,func){
    if(!this.prototype[name]){
        this.prototype[name] = func;
    } 
    return this
}

//处理父类方法的方法
Object.method('superior',function(name){
    var that = this,method = that[name];
    return function(){
        return method.apply(that,arguments);  
    };
});

var coolcat = function(spec){
    var that = cat(spec),
    super_get_name = that.superior('get_name');
    //super_get_name = that.get_name;
    that.get_name = function(n){
        return 'like ' + super_get_name() + ' baby'; 
    }
    return that;
}

var coolCat = coolcat({name:'Bix'});
var name = coolCat.get_name();
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;如果对象的所有状态都是私有的，那么该对象就成为一个“防伪(temper-proof)对象”。该对象的属性可以被替换或删除，但该对象的完整性不会受到损害。如果我们用韩淑华的样式创建一个个对象，并且该对象的所有方法都不使用this或that，那么该对象就是持久性(durable)的。一个持久性对象就是一个简单功能函数的集合。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;部件&quot;&gt;部件&lt;/h3&gt;
&lt;p&gt;我们可以从一套部件中把对象组装出来。例如，可以构造一个给任何对象添加事件与处理特性的函数。它会给对象添加一个on方法、一个fire方法和一个私有的事件注册表对象:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var eventuality = function(that){
    var registry = {};

    that.on = function(type, method, parameters){
        var handler = {
            method : method,
            parameters : parameters
        };

        if(registry.hasOwnProperty(type)){
            registry[type].push(handler);
        }else{
            registry[type] = [handler];
        }
        return this;
    };

    that.fire = function(event){
        var array,
            func,
            handler,
            i,
            type = typeof event === &quot;string&quot; ? event : event.type;

        if(registry.hasOwnProperty(type)){
            array = registry[type];
            for(i = 0; i &amp;lt; array.length; i++){
                handler = array[i];
                func = handler.method;
                if(typeof func === &quot;string&quot;){
                    func = this[func];
                }
                func.apply(this, handler.parameters || [event]);
            }
        }
        return this;
    };

//  that.get_registry = function(){
//      return registry;
//  };s

    return that;
};&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-09-02 17:14:09</pubDate>
            <link>http://sikisama.github.io/blog/js_thegoodpart_object_function.html</link>
            <guid isPermaLink="true">http://sikisama.github.io/blog/js_thegoodpart_object_function.html</guid>
                                               <category>javascript</category>
                                    </item>
                <item>
            <title>php访问网络共享资源和本地文件</title>
            <description>
            &lt;!--
author: zhangxuefeng
date: 2016-08-26
title: php访问网络共享资源和本地文件
tags: PHP,windows
category:PHP
status: publish
summary: php访问windows共享文件
--&gt;
&lt;blockquote&gt;
&lt;p&gt;PHP访问局域网上其他计算机共享资源的配置：
有A（192.168.1.1） B（192.168.1.2） 两台机子。
在A上装有appache，要访问B的共享资源，如pic_gather。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$filename = &quot;//192.168.1.31/pic_gather/figure/1.png&quot;;  
$size = filesize($filename);  
echo $size;  &lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;step1&quot;&gt;step1&lt;/h3&gt;
&lt;p&gt;必须保证pic_gather已经能被访问（其中包括防火墙设置，共享设置，这里就不具体讲了），可以测试下，在电脑的资源管理器（应该这么叫的吧，附上图）上输入\192.168.1.2\pic_gather，能打开B机上的文件&lt;/p&gt;
&lt;h3 id=&quot;step2&quot;&gt;step2&lt;/h3&gt;
&lt;p&gt;A、B两天计算机必须在一个工作组下面（名称随意自己设置，但必须是一个工作组哦）（XP是 我的电脑-&amp;gt;右键-&amp;gt;属性-&amp;gt;计算机名称-&amp;gt;更改-&amp;gt;工作组，更改完得重启计算机的）（win是 计算机-&amp;gt;右键-&amp;gt;属性-&amp;gt;高级系统设置-&amp;gt;计算机名称-&amp;gt;更改-&amp;gt;工作组，更改完得重启计算机的）。(ps:作者表示，我没有在相同的组里面，依然可以)&lt;/p&gt;
&lt;h3 id=&quot;step3&quot;&gt;step3&lt;/h3&gt;
&lt;p&gt;B要开启guest。(ps:作者表示，我没有启用来宾模式，依然可以)&lt;/p&gt;
&lt;h3 id=&quot;step4&quot;&gt;step4&lt;/h3&gt;
&lt;p&gt;B上pic_gather的文件夹在共享设定方面要设定为“允许用户更改我的文件（这个可以再第一步就设置好，不设置的话，只能访问不能修改）&lt;/p&gt;
&lt;h3 id=&quot;step5&quot;&gt;step5&lt;/h3&gt;
&lt;p&gt;在A上， cmd里面输入services.msc后，双击apache服务，在“登录”选项卡里面，把运行账号改为登录windows的超级账号（比如Administrator），重启apache服务。(ps 想作者是一个懒人，没有装appache，只是用了集成软件zend，所以服务里面只有appche2.2-zend，其实原理一样的)。&lt;/p&gt;            </description>
            <pubDate>2016-08-26 10:59:10</pubDate>
            <link>http://sikisama.github.io/blog/php_access_share.html</link>
            <guid isPermaLink="true">http://sikisama.github.io/blog/php_access_share.html</guid>
                                               <category>PHP</category>
                                    </item>
                <item>
            <title>javascript-闭包</title>
            <description>
            &lt;!--
author: zhangxuefeng
date: 2016-08-18
title: javascript-闭包
tags: javascript
category:javascript
status: publish
summary: javascript的闭包特性
--&gt;
&lt;h2 id=&quot;js函数特点&quot;&gt;js函数特点&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。另一方面，在函数外部自然无法读取函数内的局部变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;    //外部读取内部
　  var n=999;
　　function f1(){
　　　　alert(n);
　　}
　　f1(); // 999
　　
　　//内部读取外部
　　function f1(){
　　　  var n=999;
　　}
　　alert(n); // error
　　&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;如何从外部读取内部变量？&quot;&gt;如何从外部读取内部变量？&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在内部定义一个访问该变量的函数，并将其return&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;function f1(){
　　　　var n=999;
　　　　function f2(){
　　　　　　alert(n); 
　　　　}
　　　　return f2;
　　}
　　var result=f1();
　　result(); // 999&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;闭包的概念&quot;&gt;闭包的概念&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;闭包就是能够读取其他函数内部变量的函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成&amp;quot;定义在一个函数内部的函数&amp;quot;。
所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。&lt;/p&gt;
&lt;h2 id=&quot;闭包的用处&quot;&gt;闭包的用处&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;可以读取函数内部的变量&lt;/li&gt;
&lt;li&gt;可以让这些变量的值始终保持在内存中&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;　function f1(){
　　　　var n=999;
　　　　nAdd=function(){n+=1}
　　　　function f2(){
　　　　　　alert(n);
　　　　}
　　　　return f2;
　　}
　　var result=f1();
　　result(); // 999
　　nAdd();
　　result(); // 1000&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。&lt;/p&gt;
&lt;p&gt;为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。&lt;/p&gt;
&lt;p&gt;这段代码中另一个值得注意的地方，就是&amp;quot;nAdd=function(){n+=1}&amp;quot;这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value）&lt;/p&gt;
&lt;/blockquote&gt;            </description>
            <pubDate>2016-09-02 17:14:09</pubDate>
            <link>http://sikisama.github.io/blog/js_closure.html</link>
            <guid isPermaLink="true">http://sikisama.github.io/blog/js_closure.html</guid>
                                               <category>javascript</category>
                                    </item>
                <item>
            <title>js中的apply与call</title>
            <description>
            &lt;!--
author: zhangxuefeng
date: 2016-08-18
title: js中的apply与call
tags: javascript
category:javascript
status: publish
summary: js中关于函数与对象的关键概念
--&gt;
&lt;p&gt;js 里函数调用有 4 种模式：方法调用、正常函数调用、构造器函数调用、apply/call 调用。&lt;/p&gt;
&lt;p&gt;同时，无论哪种函数调用除了你声明时定义的形参外，还会自动添加 2 个形参，分别是 this 和 arguments。&lt;/p&gt;
&lt;h3 id=&quot;方法调用&quot;&gt;方法调用&lt;/h3&gt;
&lt;p&gt;函数是一个对象的属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var a = {    
    v : 0,    
    f : function(xx) {                
        this.v = xx;    
    }
}
a.f(5);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面函数里的 this 就绑定的是这个对象 a。所以 this.v 可以取到对象 a 的属性 v。&lt;/p&gt;
&lt;h3 id=&quot;正常函数调用&quot;&gt;正常函数调用&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;function f(xx) {        
    this.x = xx;
}
f(5);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;f 里的 this 绑定的是全局对象，如果是在浏览器运行的解释器中，一般来说是 window 对象。所以这里 this.x 访问的其实是 window.x ，当然，如果 window 没有 x 属性，相当于是给 window 对象添加了一个 x 属性，同时赋值。&lt;/p&gt;
&lt;h3 id=&quot;构造器函数调用&quot;&gt;构造器函数调用&lt;/h3&gt;
&lt;p&gt;如果你在一个函数前面带上 new 关键字来调用，那么 js 会创建一个 prototype 属性是此函数的一个新对象，同时在调用这个函数的时候，把 this 绑定到这个新对象上。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function a(xx) {        
    this.m = xx;
}
var b = new a(5);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里this 绑定的就不再是前面讲到的全局对象了，而是这里说的创建的新对象。&lt;/p&gt;
&lt;h2 id=&quot;apply/call 调用&quot;&gt;apply/call 调用&lt;/h2&gt;
&lt;p&gt;在 js 里，&lt;strong&gt;函数其实也是一个对象&lt;/strong&gt;，那么函数自然也可以拥有它自己的方法。在 js 里，每个函数都有一个公共的 prototype —— Function，而这个原型自带有好几个属性和方法，其中就有这里困惑的 bind、call、apply 方法。&lt;/p&gt;
&lt;p&gt;先说 apply 方法，它让我们构造一个参数数组传递给函数，同时可以自己来设置 this 的值，这就是它最强大的地方，上面的 3 种函数调用方式，你可以看到，this 都是自动绑定的，没办法由你来设，当你想设的时候，就可以用 apply() 了。apply 函数接收 2 个参数，第一个是传递给这个函数用来绑定 this 的值，第二个是一个参数数组。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function a(xx) {        
    this.b = xx;
}
var o = {};
a.apply(o, [5]);
alert(a.b);    // undefined
alert(o.b);    // 5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面 apply() 接收两个参数，第一个是绑定 this 的值，第二个是一个参数数组，注意它是一个数组，你想传递给这个函数的所有参数都放在数组里，然后 apply() 函数会在调用函数时自动帮你把数组展开。而 call() 呢，它的第一个参数也是绑定给 this 的值，但是后面接受的是不定参数，而不再是一个数组，也就是说你可以像平时给函数传参那样把这些参数一个一个传递。所以如果一定要说有什么区别的话，看起来是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function a(xx, yy) {    
    alert(xx, yy);    
    alert(this);    
    alert(arguments);
}
a.apply(null, [5, 55]);
a.call(null, 5, 55);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后再来说 bind() 函数，上面讲的无论是 call() 也好， apply() 也好，都是立马就调用了对应的函数，而 bind() 不会， bind() 会生成一个新的函数，bind() 函数的参数跟 call() 一致，第一个参数也是绑定 this 的值，后面接受传递给函数的不定参数。 bind() 生成的新函数返回后，你想什么时候调就什么时候调，看下代码就明白了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var m = {   
    &quot;x&quot; : 1
};
function foo(y) {
    alert(this.x + y);
}
foo.apply(m, [5]);
foo.call(m, 5);
var foo1 = foo.bind(m, 5);
foo1();&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;补充：&quot;&gt;补充：&lt;/h3&gt;
&lt;p&gt;在 js 里想定义一个函数，于是你会这么写:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function jam() {};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实这是 js 里的一种语法糖，它等价于：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var jam = function() {};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后你想执行这个函数，脑洞大开的你会这么写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function jam() {}();&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是这么写就报错了，其实这种写法也不算错，因为它确实是 js 支持的函数表达式，但是同时 js 又规定以 function 开头的语句被认为是函数语句，而函数语句后面是肯定不会带 () 的，所以才报错，于是聪明的人想出来，加上一对括号就可以了。于是就变成了这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(function jam() {}());&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就定义了一个函数同时也执行它&lt;/p&gt;            </description>
            <pubDate>2016-08-18 16:01:09</pubDate>
            <link>http://sikisama.github.io/blog/js_apply_call.html</link>
            <guid isPermaLink="true">http://sikisama.github.io/blog/js_apply_call.html</guid>
                                               <category>javascript</category>
                                    </item>
                <item>
            <title>PHP非阻塞模式</title>
            <description>
            &lt;!--
author: zhangxuefeng
date: 2016-08-16
title: PHP非阻塞模式
tags: 阻塞模式,PHP
category:PHP
status: publish
summary: PHP非阻塞模式
--&gt;
&lt;p&gt;让PHP不再阻塞当PHP作为后端处理需要完成一些长时间处理，为了快速响应页面请求，不作结果返回判断的情况下，可以有如下措施：&lt;/p&gt;
&lt;h3 id=&quot;一、FastCGI模式，使用fastcgi_finish_request()能马上结束会话，但PHP线程继续在跑。&quot;&gt;一、FastCGI模式，使用fastcgi_finish_request()能马上结束会话，但PHP线程继续在跑。&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;echo &quot;program start.&quot;;

file_put_contents('log.txt','start-time:'.date('Y-m-d H:i:s'), FILE_APPEND);
fastcgi_finish_request();
sleep(1);
echo 'debug...';
file_put_contents('log.txt', 'start-proceed:'.date('Y-m-d H:i:s'), FILE_APPEND);

sleep(10);
file_put_contents('log.txt', 'end-time:'.date('Y-m-d H:i:s'), FILE_APPEND);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个例子输出结果可看到输出program start.后会话就返回了，所以debug那个输出浏览器是接收不到的，而log.txt文件能完整接收到三个完成时间。&lt;/p&gt;
&lt;h3 id=&quot;二、使用fsockopen、cUrl的非阻塞模式请求另外的网址&quot;&gt;二、使用fsockopen、cUrl的非阻塞模式请求另外的网址&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$fp = fsockopen(&quot;www.example.com&quot;, 80, $errno, $errstr, 30);
if (!$fp) die('error fsockopen');
stream_set_blocking($fp,0);
$http = &quot;GET /save.php  / HTTP/1.1\r\n&quot;;    
$http .= &quot;Host: www.example.com\r\n&quot;;    
$http .= &quot;Connection: Close\r\n\r\n&quot;;
fwrite($fp,$http);
fclose($fp);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用cURL中的curl&lt;em&gt;multi&lt;/em&gt;*函数发送异步请求&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$cmh = curl_multi_init();
$ch1 = curl_init();
curl_setopt($ch1, CURLOPT_URL, &quot;http://localhost:6666/child.php&quot;);
curl_multi_add_handle($cmh, $ch1);
curl_multi_exec($cmh, $active);
echo &quot;End\n&quot;;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;三、使用Gearman、Swoole扩展&quot;&gt;三、使用Gearman、Swoole扩展&lt;/h3&gt;
&lt;p&gt;Gearman是一个具有php扩展的分布式异步处理框架，能处理大批量异步任务；
Swoole最近很火，有很多异步方法，使用简单。&lt;/p&gt;
&lt;h3 id=&quot;四、使用redis等缓存、队列，将数据写入缓存，使用后台计划任务实现数据异步处理。&quot;&gt;四、使用redis等缓存、队列，将数据写入缓存，使用后台计划任务实现数据异步处理。&lt;/h3&gt;
&lt;p&gt;这个方法在常见的大流量架构中应该很常见吧&lt;/p&gt;
&lt;h3 id=&quot;五、极端的情况下，可以调用系统命令，可以将数据传给后台任务执行，个人感觉不是很高效。&quot;&gt;五、极端的情况下，可以调用系统命令，可以将数据传给后台任务执行，个人感觉不是很高效。&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$cmd = 'nohup php ./processd.php $someVar &amp;gt;/dev/null  &amp;amp;';
`$cmd`&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;六、外国佬的大招，没看懂，php原生支持&quot;&gt;六、外国佬的大招，没看懂，php原生支持&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://nikic.github.io/2012/12/22/Cooperative-multitasking-using-coroutines-in-PHP.html&quot;&gt;http://nikic.github.io/2012/12/22/Cooperative-multitasking-using-coroutines-in-PHP.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;七、安装pcntl扩展，使用pcntl_fork生成子进程异步执行任务，个人觉得是最方便的，但也容易出现zombie process。&quot;&gt;七、安装pcntl扩展，使用pcntl_fork生成子进程异步执行任务，个人觉得是最方便的，但也容易出现zombie process。&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;if (($pid = pcntl_fork()) == 0) {
    child_func();    //子进程函数，主进程运行
} else {
    father_func();   //主进程函数
}

echo &quot;Process &quot; . getmypid() . &quot; get to the end.\n&quot;;

function father_func() {
    echo &quot;Father pid is &quot; . getmypid() . &quot;\n&quot;;
}

function child_func() {
    sleep(6);
    echo &quot;Child process exit pid is &quot; . getmypid() . &quot;\n&quot;;
    exit(0);
}&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-08-18 16:01:09</pubDate>
            <link>http://sikisama.github.io/blog/php_unblocked.html</link>
            <guid isPermaLink="true">http://sikisama.github.io/blog/php_unblocked.html</guid>
                                               <category>PHP</category>
                                    </item>
                <item>
            <title>nodejs入门</title>
            <description>
            &lt;!--
author: zhangxuefeng
date: 2016-08-11
title: nodejs入门
tags: nodejs
category:javascript
status: publish
summary: nodejs经典入门
--&gt;
&lt;p&gt;&lt;a href=&quot;http://www.nodebeginner.org/index-zh-cn.html&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;服务端JavaScript&quot;&gt;服务端JavaScript&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;JavaScript最早是运行在浏览器中，然而浏览器只是提供了一个上下文，它定义了使用JavaScript可以做什么，但并没有“说”太多关于JavaScript语言本身可以做什么。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;事实上，JavaScript是一门“完整”的语言：&lt;/p&gt;
&lt;p&gt;它可以使用在不同的上下文中，其能力与其他同类语言相比有过之而无不及。
Node.js事实上就是另外一种上下文，它允许在后端（脱离浏览器环境）运行JavaScript代码。&lt;/p&gt;
&lt;p&gt;要实现在后台运行JavaScript代码，代码需要先被解释然后正确的执行。Node.js的原理正是如此，它使用了Google的V8虚拟机（Google的Chrome浏览器使用的JavaScript执行环境），来解释和执行JavaScript代码。&lt;/p&gt;
&lt;p&gt;除此之外，伴随着Node.js的还有许多有用的模块，它们可以简化很多重复的劳作，比如向终端输出字符串。&lt;/p&gt;
&lt;p&gt;因此，Node.js事实上既是一个运行时环境，同时又是一个库。&lt;/p&gt;
&lt;h2 id=&quot;分析HTTP服务器&quot;&gt;分析HTTP服务器&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Node.js是事件驱动的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们创建了服务器，并且向创建它的方法传递了一个函数。无论何时我们的服务器收到一个请求，这个函数就会被调用。&lt;/p&gt;
&lt;p&gt;这个就是传说中的 回调 。我们给某个方法传递了一个函数，这个方法在有相应事件发生时调用这个函数来进行 回调 。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var http = require(&quot;http&quot;);
http.createServer(function(request,response){
  response.writeHead(200,{&quot;Content-Type&quot;:&quot;text/plain&quot;});
  response.write(&quot;Hello World&quot;);
  response.end();
}).listen(8888);&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;如何来进行请求的“路由”&quot;&gt;如何来进行请求的“路由”&lt;/h2&gt;
&lt;p&gt;我们需要的所有数据都会包含在request对象中，该对象作为onRequest()回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的Node.JS模块，它们分别是url和querystring模块。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; url.parse(string).query
                                           |
           url.parse(string).pathname      |
                       |                   |
                       |                   |
                     ------ -------------------
http://localhost:8888/start?foo=bar&amp;amp;hello=world
                                ---       -----
                                 |          |
                                 |          |
              querystring(string)[&quot;foo&quot;]    |
                                            |
                         querystring(string)[&quot;hello&quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在我们来给onRequest()函数加上一些逻辑，用来找出浏览器请求的URL路径：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var http = require(&quot;http&quot;);
var url = require(&quot;url&quot;);

function start() {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);
    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
    response.write(&quot;Hello World&quot;);
    response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log(&quot;Server has started.&quot;);
}

exports.start = start;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;使用依赖注入的方式较松散地添加路由模块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;建立一个名为router.js的文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function route(pathname) {
  console.log(&quot;About to route a request for &quot; + pathname);
}

exports.route = route;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;扩展start函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var http = require(&quot;http&quot;);
var url = require(&quot;url&quot;);

function start(route) {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);

    route(pathname);

    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
    response.write(&quot;Hello World&quot;);
    response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log(&quot;Server has started.&quot;);
}

exports.start = start;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更新index.js&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var server = require(&quot;./server&quot;);
var router = require(&quot;./router&quot;);

server.start(router.route);&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;行为驱动执行&quot;&gt;行为驱动执行&lt;/h2&gt;
&lt;p&gt;将函数作为参数传递并不仅仅出于技术上的考量。对软件设计来说，这其实是个哲学问题。想想这样的场景：在index文件中，我们可以将router对象传递进去，服务器随后可以调用这个对象的route函数。&lt;/p&gt;
&lt;p&gt;就像这样，我们传递一个东西，然后服务器利用这个东西来完成一些事。嗨那个叫路由的东西，能帮我把这个路由一下吗？&lt;/p&gt;
&lt;p&gt;但是服务器其实不需要这样的东西。它只需要把事情做完就行，其实为了把事情做完，你根本不需要东西，你需要的是动作。&lt;strong&gt;也就是说，你不需要名词，你需要动词。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;理解了这个概念里最核心、最基本的思想转换后，我自然而然地理解了函数编程。&lt;/p&gt;
&lt;p&gt;我是在读了Steve Yegge的大作&lt;a href=&quot;http://steve-yegge.blogspot.sg/2006/03/execution-in-kingdom-of-nouns.html&quot;&gt;名词王国中的死刑&lt;/a&gt;之后理解函数编程。&lt;/p&gt;
&lt;h2 id=&quot;路由给真正的请求处理程序&quot;&gt;路由给真正的请求处理程序&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在C++或C#中，当我们谈到对象，指的是类或者结构体的实例。对象根据他们实例化的模板（就是所谓的类），会拥有不同的属性和方法。但在JavaScript里对象不是这个概念。在JavaScript中，对象就是一个键/值对的集合 -- 你可以把JavaScript的对象想象成一个键为字符串类型的字典。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但如果JavaScript的对象仅仅是键/值对的集合，它又怎么会拥有方法呢？好吧，这里的值可以是字符串、数字或者……函数！&lt;/p&gt;
&lt;p&gt;我们先将这个对象引入到主文件index.js中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var server = require(&quot;./server&quot;);
var router = require(&quot;./router&quot;);
var requestHandlers = require(&quot;./requestHandlers&quot;);

var handle = {}
handle[&quot;/&quot;] = requestHandlers.start;
handle[&quot;/start&quot;] = requestHandlers.start;
handle[&quot;/upload&quot;] = requestHandlers.upload;

server.start(router.route, handle);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然handle并不仅仅是一个“东西”（一些请求处理程序的集合），我还是建议以一个动词作为其命名，这样做可以让我们在路由中使用更流畅的表达式\&lt;/p&gt;
&lt;p&gt;在完成了对象的定义后，我们把它作为额外的参数传递给服务器，为此将server.js修改如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var http = require(&quot;http&quot;);
var url = require(&quot;url&quot;);

function start(route, handle) {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);

    route(handle, pathname);

    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
    response.write(&quot;Hello World&quot;);
    response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log(&quot;Server has started.&quot;);
}

exports.start = start;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相应地在route.js文件中修改route()函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function route(handle, pathname) {
  console.log(&quot;About to route a request for &quot; + pathname);
  if (typeof handle[pathname] === 'function') {
    handle[pathname]();
  } else {
    console.log(&quot;No request handler found for &quot; + pathname);
  }
}

exports.route = route;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过以上代码，我们首先检查给定的路径对应的请求处理程序是否存在，如果存在的话直接调用相应的函数。我们可以用从关联数组中获取元素一样的方式从传递的对象中获取请求处理函数，因此就有了简洁流畅的形如handle[pathname]();的表达式，这个感觉就像在前方中提到的那样：“嗨，请帮我处理了这个路径”。&lt;/p&gt;
&lt;h2 id=&quot;阻塞与非阻塞&quot;&gt;阻塞与非阻塞&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在node中除了代码，所有一切都是并行执行的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Node.js可以在不新增额外线程的情况下，依然可以对任务进行并行处理 —— Node.js是单线程的。它通过事件轮询（event loop）来实现并行操作，对此，我们应该要充分利用这一点 —— 尽可能的避免阻塞操作，取而代之，多使用非阻塞操作。&lt;/p&gt;
&lt;p&gt;对于Node.js来说，它是这样处理的：“嘿，probablyExpensiveFunction()（这里指的就是需要花时间处理的函数），你继续处理你的事情，我（Node.js线程）先不等你了，我继续去处理你后面的代码，请你提供一个callbackFunction()，等你处理完之后我会去调用该回调函数的，谢谢！”&lt;/p&gt;
&lt;h2 id=&quot;以非阻塞操作进行请求响应&quot;&gt;以非阻塞操作进行请求响应&lt;/h2&gt;
&lt;p&gt;相对采用将内容传递给服务器的方式，我们这次采用将服务器“传递”给内容的方式。 从实践角度来说，就是将response对象（从服务器的回调函数onRequest()获取）通过请求路由传递给请求处理程序。 随后，处理程序就可以采用该对象上的函数来对请求作出响应。&lt;/p&gt;
&lt;h2 id=&quot;处理POST请求&quot;&gt;处理POST请求&lt;/h2&gt;
&lt;p&gt;考虑这样一个简单的例子：我们显示一个文本区（textarea）供用户输入内容，然后通过POST请求提交给服务器。最后，服务器接受到请求，通过处理程序将输入的内容展示到浏览器中。&lt;/p&gt;
&lt;p&gt;/start请求处理程序用于生成带文本区的表单，因此，我们将requestHandlers.js修改为如下形式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function start(response) {
  console.log(&quot;Request handler 'start' was called.&quot;);

  var body = '&amp;lt;html&amp;gt;'+
    '&amp;lt;head&amp;gt;'+
    '&amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; '+
    'charset=UTF-8&quot; /&amp;gt;'+
    '&amp;lt;/head&amp;gt;'+
    '&amp;lt;body&amp;gt;'+
    '&amp;lt;form action=&quot;/upload&quot; method=&quot;post&quot;&amp;gt;'+
    '&amp;lt;textarea name=&quot;text&quot; rows=&quot;20&quot; cols=&quot;60&quot;&amp;gt;&amp;lt;/textarea&amp;gt;'+
    '&amp;lt;input type=&quot;submit&quot; value=&quot;Submit text&quot; /&amp;gt;'+
    '&amp;lt;/form&amp;gt;'+
    '&amp;lt;/body&amp;gt;'+
    '&amp;lt;/html&amp;gt;';

    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/html&quot;});
    response.write(body);
    response.end();
}

function upload(response) {
  console.log(&quot;Request handler 'upload' was called.&quot;);
  response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
  response.write(&quot;Hello Upload&quot;);
  response.end();
}

exports.start = start;
exports.upload = upload;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了使整个过程非阻塞，Node.js会将POST数据拆分成很多小的数据块，然后通过触发特定的事件，将这些小数据块传递给回调函数。这里的特定的事件有data事件（表示新的小数据块到达了）以及end事件（表示所有的数据都已经接收完毕）。&lt;/p&gt;
&lt;p&gt;我们需要告诉Node.js当这些事件触发的时候，回调哪些函数。怎么告诉呢？ 我们通过在request对象上注册监听器（listener） 来实现。这里的request对象是每次接收到HTTP请求时候，都会把该对象传递给onRequest回调函数。&lt;/p&gt;
&lt;p&gt;如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;request.addListener(&quot;data&quot;, function(chunk) {
  // called when a new chunk of data was received
});

request.addListener(&quot;end&quot;, function() {
  // called when all chunks of data have been received
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将data和end事件的回调函数直接放在服务器中，在data事件回调中收集所有的POST数据，当接收到所有数据，触发end事件后，其回调函数调用请求路由，并将数据传递给它，然后，请求路由再将该数据传递给请求处理程序。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var http = require(&quot;http&quot;);
var url = require(&quot;url&quot;);

function start(route, handle) {
  function onRequest(request, response) {
    var postData = &quot;&quot;;
    var pathname = url.parse(request.url).pathname;
    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);

    request.setEncoding(&quot;utf8&quot;);

    request.addListener(&quot;data&quot;, function(postDataChunk) {
      postData += postDataChunk;
      console.log(&quot;Received POST data chunk '&quot;+
      postDataChunk + &quot;'.&quot;);
    });

    request.addListener(&quot;end&quot;, function() {
      route(handle, pathname, response, postData);
    });

  }

  http.createServer(onRequest).listen(8888);
  console.log(&quot;Server has started.&quot;);
}

exports.start = start;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们接下来在/upload页面，展示用户输入的内容。要实现该功能，我们需要将postData传递给请求处理程序，修改router.js为如下形式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function route(handle, pathname, response, postData) {
  console.log(&quot;About to route a request for &quot; + pathname);
  if (typeof handle[pathname] === 'function') {
    handle[pathname](response, postData);
  } else {
    console.log(&quot;No request handler found for &quot; + pathname);
    response.writeHead(404, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
    response.write(&quot;404 Not found&quot;);
    response.end();
  }
}

exports.route = route;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，在requestHandlers.js中，我们将数据包含在对upload请求的响应中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function start(response, postData) {
  console.log(&quot;Request handler start was called.&quot;);

  var body = '&amp;lt;html&amp;gt;'+
    '&amp;lt;head&amp;gt;'+
    '&amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; '+
    'charset=UTF-8&quot; /&amp;gt;'+
    '&amp;lt;/head&amp;gt;'+
    '&amp;lt;body&amp;gt;'+
    '&amp;lt;form action=&quot;/upload&quot; method=&quot;post&quot;&amp;gt;'+
    '&amp;lt;textarea name=&quot;text&quot; rows=&quot;20&quot; cols=&quot;60&quot;&amp;gt;&amp;lt;/textarea&amp;gt;'+
    '&amp;lt;input type=&quot;submit&quot; value=&quot;Submit text&quot; /&amp;gt;'+
    '&amp;lt;/form&amp;gt;'+
    '&amp;lt;/body&amp;gt;'+
    '&amp;lt;/html&amp;gt;';

    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/html&quot;});
    response.write(body);
    response.end();
}

function upload(response, postData) {
  console.log(&quot;Request handler upload was called.&quot;);
  response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
  //querystring.parse(postData).text;
  response.write(&quot;You've sent: &quot; + postData);
  response.end();
}

exports.start = start;
exports.upload = upload;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;处理文件上传&quot;&gt;处理文件上传&lt;/h2&gt;
&lt;p&gt;这里我们要用到的外部模块是Felix Geisendörfer开发的node-formidable模块。它对解析上传的文件数据做了很好的抽象。&lt;/p&gt;
&lt;p&gt;Node.js有它自己的包管理器，叫NPM。它可以让安装Node.js的外部模块变得非常方便。通过如下一条命令就可以完成该模块的安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install formidable&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们来添加/showURL的请求处理程序，该处理程序直接硬编码将文件/tmp/test.png内容展示到浏览器中。将requestHandlers.js修改为如下形式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var querystring = require(&quot;querystring&quot;),
    fs = require(&quot;fs&quot;);

function start(response, postData) {
  console.log(&quot;Request handler 'start' was called.&quot;);

  var body = '&amp;lt;html&amp;gt;'+
    '&amp;lt;head&amp;gt;'+
    '&amp;lt;meta http-equiv=&quot;Content-Type&quot; '+
    'content=&quot;text/html; charset=UTF-8&quot; /&amp;gt;'+
    '&amp;lt;/head&amp;gt;'+
    '&amp;lt;body&amp;gt;'+
    '&amp;lt;form action=&quot;/upload&quot; method=&quot;post&quot;&amp;gt;'+
    '&amp;lt;textarea name=&quot;text&quot; rows=&quot;20&quot; cols=&quot;60&quot;&amp;gt;&amp;lt;/textarea&amp;gt;'+
    '&amp;lt;input type=&quot;submit&quot; value=&quot;Submit text&quot; /&amp;gt;'+
    '&amp;lt;/form&amp;gt;'+
    '&amp;lt;/body&amp;gt;'+
    '&amp;lt;/html&amp;gt;';

    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/html&quot;});
    response.write(body);
    response.end();
}

function upload(response, postData) {
  console.log(&quot;Request handler 'upload' was called.&quot;);
  response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
  response.write(&quot;You've sent the text: &quot;+
  querystring.parse(postData).text);
  response.end();
}

function show(response, postData) {
  console.log(&quot;Request handler 'show' was called.&quot;);
  fs.readFile(&quot;/tmp/test.png&quot;, &quot;binary&quot;, function(error, file) {
    if(error) {
      response.writeHead(500, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
      response.write(error + &quot;\n&quot;);
      response.end();
    } else {
      response.writeHead(200, {&quot;Content-Type&quot;: &quot;image/png&quot;});
      response.write(file, &quot;binary&quot;);
      response.end();
    }
  });
}

exports.start = start;
exports.upload = upload;
exports.show = show;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;好，最后我们要的就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在/start表单中添加一个文件上传元素&lt;/li&gt;
&lt;li&gt;将node-formidable整合到我们的upload请求处理程序中，用于将上传的图片保存到/tmp/test.png&lt;/li&gt;
&lt;li&gt;将上传的图片内嵌到/uploadURL输出的HTML中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一项很简单。只需要在HTML表单中，添加一个multipart/form-data的编码类型，移除此前的文本区，添加一个文件上传组件，并将提交按钮的文案改为“Upload file”即可。 如下requestHandler.js所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var querystring = require(&quot;querystring&quot;),
    fs = require(&quot;fs&quot;);

function start(response, postData) {
  console.log(&quot;Request handler 'start' was called.&quot;);

  var body = '&amp;lt;html&amp;gt;'+
    '&amp;lt;head&amp;gt;'+
    '&amp;lt;meta http-equiv=&quot;Content-Type&quot; '+
    'content=&quot;text/html; charset=UTF-8&quot; /&amp;gt;'+
    '&amp;lt;/head&amp;gt;'+
    '&amp;lt;body&amp;gt;'+
    '&amp;lt;form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot; '+
    'method=&quot;post&quot;&amp;gt;'+
    '&amp;lt;input type=&quot;file&quot; name=&quot;upload&quot;&amp;gt;'+
    '&amp;lt;input type=&quot;submit&quot; value=&quot;Upload file&quot; /&amp;gt;'+
    '&amp;lt;/form&amp;gt;'+
    '&amp;lt;/body&amp;gt;'+
    '&amp;lt;/html&amp;gt;';

    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/html&quot;});
    response.write(body);
    response.end();
}

function upload(response, postData) {
  console.log(&quot;Request handler 'upload' was called.&quot;);
  response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
  response.write(&quot;You've sent the text: &quot;+
  querystring.parse(postData).text);
  response.end();
}

function show(response, postData) {
  console.log(&quot;Request handler 'show' was called.&quot;);
  fs.readFile(&quot;/tmp/test.png&quot;, &quot;binary&quot;, function(error, file) {
    if(error) {
      response.writeHead(500, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
      response.write(error + &quot;\n&quot;);
      response.end();
    } else {
      response.writeHead(200, {&quot;Content-Type&quot;: &quot;image/png&quot;});
      response.write(file, &quot;binary&quot;);
      response.end();
    }
  });
}

exports.start = start;
exports.upload = upload;
exports.show = show;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下一步相对比较复杂。这里有这样一个问题： 我们需要在upload处理程序中对上传的文件进行处理，这样的话，我们就需要将request对象传递给node-formidable的form.parse函数。&lt;/p&gt;
&lt;p&gt;但是，我们有的只是response对象和postData数组。看样子，我们只能不得不将request对象从服务器开始一路通过请求路由，再传递给请求处理程序。 或许还有更好的方案，但是，不管怎么说，目前这样做可以满足我们的需求。&lt;/p&gt;
&lt;p&gt;我们从server.js开始 —— 移除对postData的处理以及request.setEncoding （这部分node-formidable自身会处理），转而采用将request对象传递给请求路由的方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var http = require(&quot;http&quot;);
var url = require(&quot;url&quot;);

function start(route, handle) {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);
    route(handle, pathname, response, request);
  }

  http.createServer(onRequest).listen(8888);
  console.log(&quot;Server has started.&quot;);
}

exports.start = start;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来是 router.js —— 我们不再需要传递postData了，这次要传递request对象：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function route(handle, pathname, response, request) {
  console.log(&quot;About to route a request for &quot; + pathname);
  if (typeof handle[pathname] === 'function') {
    handle[pathname](response, request);
  } else {
    console.log(&quot;No request handler found for &quot; + pathname);
    response.writeHead(404, {&quot;Content-Type&quot;: &quot;text/html&quot;});
    response.write(&quot;404 Not found&quot;);
    response.end();
  }
}

exports.route = route;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来，我们把处理文件上传以及重命名的操作放到一起，如下requestHandlers.js所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var querystring = require(&quot;querystring&quot;),
    fs = require(&quot;fs&quot;),
    formidable = require(&quot;formidable&quot;);

function start(response) {
  console.log(&quot;Request handler 'start' was called.&quot;);

  var body = '&amp;lt;html&amp;gt;'+
    '&amp;lt;head&amp;gt;'+
    '&amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; '+
    'charset=UTF-8&quot; /&amp;gt;'+
    '&amp;lt;/head&amp;gt;'+
    '&amp;lt;body&amp;gt;'+
    '&amp;lt;form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot; '+
    'method=&quot;post&quot;&amp;gt;'+
    '&amp;lt;input type=&quot;file&quot; name=&quot;upload&quot; multiple=&quot;multiple&quot;&amp;gt;'+
    '&amp;lt;input type=&quot;submit&quot; value=&quot;Upload file&quot; /&amp;gt;'+
    '&amp;lt;/form&amp;gt;'+
    '&amp;lt;/body&amp;gt;'+
    '&amp;lt;/html&amp;gt;';

    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/html&quot;});
    response.write(body);
    response.end();
}

function upload(response, request) {
  console.log(&quot;Request handler 'upload' was called.&quot;);

  var form = new formidable.IncomingForm();
  console.log(&quot;about to parse&quot;);
  form.parse(request, function(error, fields, files) {
    console.log(&quot;parsing done&quot;);
    fs.renameSync(files.upload.path, &quot;/tmp/test.png&quot;);
    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/html&quot;});
    response.write(&quot;received image:&amp;lt;br/&amp;gt;&quot;);
    response.write(&quot;&amp;lt;img src='/show' /&amp;gt;&quot;);
    response.end();
  });
}

function show(response) {
  console.log(&quot;Request handler 'show' was called.&quot;);
  fs.readFile(&quot;/tmp/test.png&quot;, &quot;binary&quot;, function(error, file) {
    if(error) {
      response.writeHead(500, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
      response.write(error + &quot;\n&quot;);
      response.end();
    } else {
      response.writeHead(200, {&quot;Content-Type&quot;: &quot;image/png&quot;});
      response.write(file, &quot;binary&quot;);
      response.end();
    }
  });
}

exports.start = start;
exports.upload = upload;
exports.show = show;&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-08-11 10:36:31</pubDate>
            <link>http://sikisama.github.io/blog/nodejs_guide.html</link>
            <guid isPermaLink="true">http://sikisama.github.io/blog/nodejs_guide.html</guid>
                                               <category>javascript</category>
                                    </item>
                <item>
            <title>mdx重要概念</title>
            <description>
            &lt;!--
author: zhangxuefeng
date: 2016-07-07
title: mdx重要概念
tags: mdx
category: database
status: publish
summary: mdx重要概念
--&gt;
&lt;blockquote&gt;
&lt;p&gt;Mdx为多维数据库提供了表达式语查询语法，用于cube数据，并提供了许多强大的分析函数，用于支持常用的OLAP分析。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;语法&quot;&gt;语法&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;维度、级别、成员等，一般用唯一名称UniqueName来标示，可以用[]包围name,如果name有空格或者数字开头，必须使用[],否则可以忽略。UniqueName是根据层次结构表示的一种方法。即递归显示出祖先的名称。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;维度（Dimension):维度直接用[]包围。比如Product的唯一名称为[Product]或Product。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[属性]是维度的基本构造块。 维度包含一组在属性关系基础上组织而成的属性。具有对外关系的任何属性必须具有与其相关属性关联的唯一键。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;级别（Level）:级别的UniqueName为[维度名称].[级别名称]，如[year].[2001]，同样，如果没有空格，[]可以省略，如year.[2001]。&lt;/li&gt;
&lt;li&gt;成员（Member）:成员的UniqueName格式为[维度].(Parent  Member  UniqueName).[Member Name],如：时间维上的2003年2月份的UniqueName为[2003].[1].[2]，中间的1为1季度，因为该维度的结构为年、季、月。&lt;/li&gt;
&lt;li&gt;度量（Measure）:度量实际上是属于维度维的成员，也就是说度量（Measure）是任何Cube的一个维度。如：度量Unit Sales的UnqiueName为[Measures].[Unit Sales]&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;元组、集合&quot;&gt;元组、集合&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;元组用于定义来自多维数据切片；他是由一个或多个维度的单个成员的有序集合组成。元组内不包含来自同一个维度的多个成员（可以理解为坐标），元组用（）包围。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;p&gt;（时间.[下半年]）&lt;/p&gt;
&lt;p&gt;（时间.[下半年],[产品].[手机].[Nokia]）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;集合（Set）是零个、一个或多个元组的有序集合。集合最常用于在Mdx查询中定义轴维度和切片器维度，并且同样可能只具有单个元组或可能在某些情况下为空。在Mdx语法中，元组用花括号{}来构造集合&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;举例，下面是具有两个元组的集合：&lt;/p&gt;
&lt;p&gt;{（时间.[上半年],路线.非陆地.航空），（时间.[下半年]，路线.非陆地.海路）}&lt;/p&gt;
&lt;p&gt;一个集合可包含同一个元组不止一次的出现。这样也是可以的：&lt;/p&gt;
&lt;p&gt;{时间.[下半年],时间.[下半年]}&lt;/p&gt;
&lt;p&gt;集合值以元组表示的一组成员组合，或指集合中的元组所代表的单元中的值，视集合使用的上下文而定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：单个元组的集合不等于元组。如{时间.[下半年]}不等于  时间.[下半年]。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;Mdx基本语法结构&quot;&gt;Mdx基本语法结构&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;    SELECT  [axis specification] ON COLUMNS,

                [axis specification] ON ROWS

   FROM

                [cube name]

   WHERE

              [silcer specification]&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;[axis specification]可以看成是轴的成员选择。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;[silcer specification]表示切片上的成员，可以看成过滤信息，[silcer specification]可选，如果没有指定，取系统默认的维度成员作为切片&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;轴维度和切片器维度&quot;&gt;轴维度和切片器维度&lt;/h2&gt;
&lt;p&gt;当设计多维表达式（Mdx）查询时，应用程序一般查看多维数据集并将维度集合划分为两个子集：&lt;/p&gt;
&lt;p&gt;1.查询轴 - 从此层次结构集中检索多个成员的数据。&lt;/p&gt;
&lt;p&gt;2.切片器轴 - 从此层次结构集中检索单个成员的数据。&lt;/p&gt;            </description>
            <pubDate>2016-07-05 14:51:27</pubDate>
            <link>http://sikisama.github.io/blog/mdx.html</link>
            <guid isPermaLink="true">http://sikisama.github.io/blog/mdx.html</guid>
                                               <category>database</category>
                                    </item>
                <item>
            <title>正则表达式与preg函数</title>
            <description>
            &lt;!--
author: zhangxuefeng
date: 2016-06-27
title: 正则表达式与preg函数
tags: 正则表达式
category: tool
status: publish
summary: 正则规范
--&gt;
&lt;p&gt;&lt;a href=&quot;http://www.noupe.com/development/php-regular-expressions.html&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;operator&lt;/th&gt;
&lt;th&gt;DESCRIPTION&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;The circumflex symbol marks the beginning of a pattern, although in some cases it can be omitted&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$&lt;/td&gt;
&lt;td&gt;Same as with the circumflex symbol, the dollar sign marks the end of a search pattern&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;The period matches any single character&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;It will match the preceding pattern zero or one times&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;It will match the preceding pattern one or more times&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;It will match the preceding pattern zero or more times&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;|&lt;/td&gt;
&lt;td&gt;Boolean OR&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;–&lt;/td&gt;
&lt;td&gt;Matches a range of elements&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;()&lt;/td&gt;
&lt;td&gt;Groups a different pattern elements together&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[]&lt;/td&gt;
&lt;td&gt;Matches any single character between the square brackets&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;{min, max}&lt;/td&gt;
&lt;td&gt;It is used to match exact character counts&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\d&lt;/td&gt;
&lt;td&gt;Matches any single digit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\D&lt;/td&gt;
&lt;td&gt;Matches any single non digit caharcter&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\w&lt;/td&gt;
&lt;td&gt;Matches any alpha numeric character including underscore (_)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\W&lt;/td&gt;
&lt;td&gt;Matches any non alpha numeric character excluding the underscore character&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\s&lt;/td&gt;
&lt;td&gt;Matches whitespace character&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;EXAMPLE&lt;/th&gt;
&lt;th&gt;DESCRIPTION&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;‘/hello/’&lt;/td&gt;
&lt;td&gt;It will match the word hello&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘/^hello/’&lt;/td&gt;
&lt;td&gt;It will match hello at the start of a string. Possible matches are hello or helloworld, but not worldhello&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘/hello$/’&lt;/td&gt;
&lt;td&gt;It will match hello at the end of a string.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘/he.o/’&lt;/td&gt;
&lt;td&gt;It will match any character between he and o. Possible matches are helo or heyo, but not hello&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘/he?llo/’&lt;/td&gt;
&lt;td&gt;It will match either llo or hello&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘/hello+/’&lt;/td&gt;
&lt;td&gt;It will match hello on or more time. E.g. hello or hellohello&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘/he*llo/’&lt;/td&gt;
&lt;td&gt;Matches llo, hello or hehello, but not hellooo&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘/hello&lt;/td&gt;
&lt;td&gt;world/’&lt;/td&gt;
&lt;td&gt;It will either match the word hello or world&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘/(A-Z)/’&lt;/td&gt;
&lt;td&gt;Using it with the hyphen character, this pattern will match every uppercase character from A to Z. E.g. A, B, C…&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘/[abc]/’&lt;/td&gt;
&lt;td&gt;It will match any single character a, b or c&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘/abc{1}/’&lt;/td&gt;
&lt;td&gt;Matches precisely one c character after the characters ab. E.g. matches abc, but not abcc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘/abc{1,}/’&lt;/td&gt;
&lt;td&gt;Matches one or more c character after the characters ab. E.g. matches abc or abcc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘/abc{2,4}/’&lt;/td&gt;
&lt;td&gt;Matches between two and four c character after the characters ab. E.g. matches abcc, abccc or abcccc, but not abc&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;常用函数&quot;&gt;常用函数&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://php.net/manual/zh/function.preg-match.php&quot;&gt;preg_match&lt;/a&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://php.net/manual/zh/function.preg-replace.php&quot;&gt;preg_repalce&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;game&quot;&gt;game&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://regex.alf.nu/&quot;&gt;title&lt;/a&gt;
&lt;a href=&quot;http://felixc.at/regex.alf.nu&quot;&gt;answer&lt;/a&gt;&lt;/p&gt;            </description>
            <pubDate>2016-08-05 11:00:48</pubDate>
            <link>http://sikisama.github.io/blog/reg_express.html</link>
            <guid isPermaLink="true">http://sikisama.github.io/blog/reg_express.html</guid>
                                               <category>tool</category>
                                    </item>
                <item>
            <title>Git使用指南</title>
            <description>
            &lt;!--
author: zhangxuefeng
date: 2016-06-07
title: Git使用指南
tags: Git
category:tool
status: publish
summary: 总结一些git常用的命令
--&gt;
&lt;h2 id=&quot;一.创建与添加&quot;&gt;一.创建与添加&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;1.git init //将一个目录初始化为git仓库&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建立一个空的仓库，目录下会多一个.git的隐藏文件夹，用来跟踪管理版本库。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2.git add //添加文件到缓存&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将文件添加至缓存，多个文件用空格分隔&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;git add .&lt;/strong&gt; 或 &lt;strong&gt;git add  *&lt;/strong&gt; 可以递归的添加当前目录的所有文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3.git commit -m 'comments' //记录缓存内容的快照&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将（已缓存的/已add的）文件提交到仓库，生成快照&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;4.git commit -a &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自动将在提交前已记录、修改的文件放入缓存区(跳过add)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;5.git clone [url] [new_name] //复制一个Git仓库
eg. git clone https://github.com/sikisama/sikisama.github.io
or
git clone git://github.com/sikisama/sikisama.github.io&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;二、查看与修改&quot;&gt;二、查看与修改&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;1.git status / git status -s //查看工作目录与缓存状态&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看代码在缓存与当前工作目录的状态。带-s参数显示简短的结果，第一栏是缓存（add之后），第二栏是工作目录（add之前）。&lt;/p&gt;
&lt;p&gt;用于查看上一次提交之后(commit)有什么被修改或临时提交的（add）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2.git diff  //尚未缓存的改动&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示上次提交快照（commit）之后尚未缓存(add)的所有修改。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;执行完git status 再跑一下 git diff 是好习惯&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;3.git diff --cached   //已缓存的改动&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示接下来将要写入快照的内容（after add before commit ）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;4.git diff HEAD&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看已缓存与未缓存的改动，也就是工作目录与上一次提交(commit)的更新区别，无视缓存。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;5.git diff --stat //显示摘要&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示摘要而非整个diff&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;6.git reset HEAD -- file //已缓存与未缓存的改动&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;取消&lt;/strong&gt;已经缓存（add）的内容，将缓存区恢复到做出修改之前的样子。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//回退到之前的若干个版本(commit)
git reset --hard HEAD^/HEAD~[n]
git reset --hard [commit_id]

7.git rm &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将文件从缓存区&lt;strong&gt;移除&lt;/strong&gt;，如果要在目录中保留，使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git rm --cached

8.git mv  //git rm --cached orig;mv orig new;git add new&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;三、远程仓库&quot;&gt;三、远程仓库&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;使用 git fetch 更新你的项目，使用 git push 分享你的改动。 你可以用 git remote 管理你的远程仓库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;1.git remote /git remote -v //罗列添加和删除远端仓库的别名&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当你需要与远端仓库同步的时候，不需要使用它详细的链接。Git 储存了你感兴趣的远端仓库的链接的别名或者昵称。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2.git remote add [alias] [url]//为项目添加一个远程仓库

3.git remote rm [alias] //删除现存的某个别名

4.git fetch //从远端下载新分支与数据&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;想要同步远端信息，首先 git fetch [alias] 告诉git去获取数据，然后执行 git merge [alias]/[branch]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;5.git pull //从远端仓库提取数据并尝试合并到当前分支,在git fetch 后 git merge 

6.git push [alias] [branch]//推送你的新分支到某个远端仓库&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;会将你的[branch]分支推送成[alias]远端上的[branch]分支。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;git push [alias] [branch] 将你的本地改动推送到远端仓库。 如果可以的话，它会依据你的 [branch] 的样子，推送到远端的 [branch] 去。 如果在你上次提取、合并之后，另有人推送了，Git 服务器会拒绝你的推送，知道你是最新的为止。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;修正这个问题:执行 git fetch github; git merge github/master，然后再推送。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;四、分支与合并&quot;&gt;四、分支与合并&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;执行 git branch [branchname] 来创建分支，用 git checkout [branchname] 命令切换到该分支。当切换分支的时候，git会用该分支最后提交的快照来替换工作目录的内容。使用 git merge 来合并分支。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;1.git branch //列出、创建与管理工作上下文

2.git checkout [branchname] //切换到新的分支上下文

3.git branch [branchname] //切换到新的分支上下文&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;git将还原你的工作目录到你创建分支时的样子——可以把它看做一个记录你当前进度的书签。    &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;4.git checkout -b [branchname] //创建新分支并立即切换到它

5.git branch -d [branchname] //删除分支

6.git merge [branchname] //将分支合并到当前分支&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;合并冲突&lt;/strong&gt;
不同分支修改了相同区块的代码，就会出现冲突。使用git diff 可以显示冲突的双方和冲突解决的方法。使用git add告诉git文件中的冲突已经解决。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;7.git log //显示一个分支中提交的更改记录

8.git log --online //查看紧凑简介的版本，--graph 选项查看历史中出现的分支和合并

9.git log --online master ^dev //在不想看到的分支前放一个 ^

10.git tag //给历史记录中某个重要的一点打上标签

git tag -a [v] [sha]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考资料&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://codeigniter.org.cn/&quot;&gt;git参考手册&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot;&gt;git教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;            </description>
            <pubDate>2016-08-05 11:12:07</pubDate>
            <link>http://sikisama.github.io/blog/git_instruction_manual.html</link>
            <guid isPermaLink="true">http://sikisama.github.io/blog/git_instruction_manual.html</guid>
                                               <category>tool</category>
                                    </item>
            </channel>
</rss>